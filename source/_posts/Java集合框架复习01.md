---
title: Java集合框架系统学习
copyright: true
comments: true
toc: true
date: 2019-07-04 17:23:55
tags:
- java集合框架
categories:
- Java
---

# 写在前面：

### 什么是Java集合-What？

1. Java集合是Java编程语言自带的功能。存放于java.util包下；
2. Java集合其实可以分为三个小类：Set、List、Map
3. 集合最大的目的是用来存储数据用的，不过存储的是数据的引用，也可以理解是内存地址。集合主要是便于开发者对数据进行增删改查等等操作，所以才会有“集合”这种东西。

### 为什么要学习集合-Why？

1. 笼统的说，学习集合最终是为了更好的开发程序
2. 不负责任的说，是为了考试、面试

### 如何学习集合-How？

1. 学习集合的特点

2. 学习集合的使用方法

3. 学习集合的构成原理

   这里我仅复习1和3，至于2需要在实际开发中渐进式学习

# 集合框架的两大分类：

Java集合框架可分为两大类Collection和Map，两者区别如下：

1. Collection是单列集合；Map是双列集合

2. Collection中只有Set系列要求元素唯一；Map中键唯一，值可以重复

3. Collection的数据结构是针对元素的；Map的数据结构是针对键

   ![集合框架体系图](//ws4.sinaimg.cn/large/96e311f0gy1g4nxy8vttgj20i80bu41o.jpg)

## Collection集合类

Collection ：**是一个集合接口**。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

Collections：**是一个包装类**。它包含有各种有关集合操作的**静态多态方法**。此类**不能实例化**，就像一**个工具类**，服务于Java的Collection框架。

-----

如上图，Collection体系分为两大类：Set 和 List。例如以下Java代码使用工具类collections实现排序功能，当然还有很多其他功能

### List集合

**List特点：存取有顺序；有下标索引；可以根据索引进行取值；元素也可以重复**

#### ArrayList

**线程不同步；底层原理是数组；**初始容量为10，当数组大小不足时，会自动扩充当前容量的1.5倍+1。ArrayList的元素内存地址是连续的，所以查询速度快。由于增删需要挪动数组内的数据，所以增删速度慢。为追求效率，ArrayList没有实现同步锁（synchronize）。若需要同步，可以手动添加同步锁，也可以用**Vector代替**。注意，Vector已经过时。

#### Vector（已过时）

**线程同步，但是效率低；**容量不足时，默认扩充当前容量的一倍。

#### LInkedList

**线程不同步；双向链表实现；**查询慢，增删快。查询慢是因为底层采用链表数据结构，而链表的内存地址不连续，所以查询慢。增删快是因为在增删时，不需要移动元素，只需要改变相关元素的头尾指针地址值。可以用来模拟栈和队列，栈是先进后出，而队列是先进先出。

LinkedList同时实现了List和Deque接口，可以将它看做一个顺序的容器，也可以看成一个[队列（Deque）](https://baike.baidu.com/item/队列/14580481)[^队列Deque]，同时还能看做成一个[栈（Stack）](https://baike.baidu.com/item/%E6%A0%88/12808149)[^栈Stack]。如果这样的话，LinkedList将是一个全能的超人。当你需要使用栈（Stack）和队列（Deque）时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是Java里根本没有一个叫做Deque的类（Deque是接口）。关于栈（stack）或队列（Deque），现在的首选是ArrayDeque，它有着比LinkedList（当栈stack和队列Deque使用时）更好的性能。



### Set集合

**特点：存取无序；不可以重复；没有下标。**

#### HashSet

**线程不同步，存取速度快**，内部使用HashMap进行存储数据，且提供的方法基本都是调用HashMap的方法。所以两者本质相同，元素可以为Null。

Hash表是通过HashCode和equals方法保证唯一性。

Hash表存储元素的过程：首先根据被存储的元素来计算出HashCode值，然后根据计算出的HashCode值和数组的长度进行计算出存储的下标；如果该下标位置没有元素，则直接存储。如果有元素，直接用equals方法将被存入的元素和已有的元素进行对比，若结果为真则放弃储存。如果为假，则以链表的形式进行存储。

*注意：这里如何将元素计算出HashCode值先不探讨，后面再开文章进行深入的学习*

##### 	LinkedHashSet
这个放到后面在学习。先记住一个知识点，它是基于：链表+Hash技术进行存储的。所以存取有序，元素唯一。

#### TreeSet

**线程不同步，底层原理使用二叉树结构[^1]，存储自然顺序[^2]**，元素唯一，内部使用TreeMap的SortedSet。

TreeSet保证元素唯一性的两种方法：

1. 自定义对象实现接口`Comparable`的`comparaTo`方法，该方法返回0表示相等，小于0表示准备存入的元素比被比较的元素小，否则大于0。

2. 在创建TreesSet的时候向构造器中传入比较器`Comparator`接口的实现类，实现`Comparator`接口重写`compara`方法。 

   注意：如果存入自定义对象的时候，自定义类没有实现接口`Comparable`的`comparaTo`方法。或者也没有传入比较器`Comparator`，程序将会报错`ClassCastException`异常

### Map集合

#### HashMap

#### HashTable

#### TreeMap

### 注解
[^栈Stack]: 栈是限定仅在表尾进行插入和删除操作的线性表。要搞清楚这个概念，首先要明白”栈“原来的意思，如此才能把握本质。"栈“者,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。
[^队列Deque]: 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）[线性表](https://baike.baidu.com/item/线性表)。
[^1]: 一个节点下面不能多于两个节点，[具体参见百度百科](https://baike.baidu.com/item/二叉树/1602879)。二叉树的存储过程：如果是第一个元素，将直接存入，并作为根节点。下一个元素存入之前，会和根元素比较大小，如果大于根节点则放在该节点的右边，小于则放在左边，等于就放弃不储存。后面的元素将按照上面的规则执行，直到找到合适的位置为止。
[^2]: TreeSet内部默认使用了一个Java自带的方法`comparator.compare(e1, e2)`进行比较大小。若存入的是对象，则无法进行比较大小，需要在自定义的类里实现`Comparable`接口，覆盖`compareTo`比较方法。







