{"meta":{"title":"山岚博客","subtitle":"很高兴能帮到你","description":"全干开发者","author":"山岚","url":"https://blog.gobyte.cn"},"pages":[{"title":"","date":"2019-06-09T16:39:17.000Z","updated":"2023-10-07T08:53:25.068Z","comments":true,"path":"tags/index.html","permalink":"https://blog.gobyte.cn/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"","date":"2019-06-09T16:31:38.000Z","updated":"2023-10-07T08:53:25.042Z","comments":true,"path":"categories/index.html","permalink":"https://blog.gobyte.cn/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"","date":"2019-06-09T16:39:17.000Z","updated":"2023-10-07T08:53:25.067Z","comments":true,"path":"links/index.html","permalink":"https://blog.gobyte.cn/links/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"51cto视频解析下载过程分析","slug":"51cto视频解析下载过程分析","date":"2021-04-04T10:48:29.000Z","updated":"2023-10-07T08:53:25.028Z","comments":true,"path":"post/615d4220.html","link":"","permalink":"https://blog.gobyte.cn/post/615d4220.html","excerpt":"","keywords":null,"text":"@TOC 阅读须知本内容仅为本人学习计算机技术目的，若有侵权，还请联系。本文读者若用于非法目的，后果自行承担。 获取视频链接获取课程的所有单节链接https://edu.51cto.com/center/course/index/lesson-file-list?course_id&#x3D;1187&amp;page&#x3D;1&amp;size&#x3D;120 获取视频信息发送请求，获得视频的信息： 12345678https://edu.51cto.com/center/player/play/get-lesson-info?type=course&amp;lesson_type=course $.get(this.Conf.url_auth, &#123; sign: this.sign, lesson_id: this.lid &#125;, function(e) &#123; t.setConfig(e) &#125;, \"json\")&#125; 解析：这里有2个参数：sign &#x3D; 课程ID + 常量 ；进行MD5，只要课程ID不变最终数值是不变的。例如35547的MD5为：969bc68f0c77a5c44026f8a840b0aba9 lesson_id &#x3D; 35547 ，课程ID；可以通过页面的2个变量获取： var _lid&#x3D;’35547’; var _bak_lid&#x3D;’35547’; 获取M3U8文件通过视频信息返回的JSON.dispatch[0].url，可以得到高清的视频M3U8文件地址。https://edu.51cto.com//center/player/play/m3u8?lesson_id=151970&amp;id=133999&amp;dp=high&amp;type=course&amp;lesson_type=course 解析M3U8，获取到KEY链接打开m3u8文件，找到#EXT-X-KEY:METHOD=AES-128,URI=/center/player/play/get-key?lesson_id=151970&amp;id=133999&amp;type=course&amp;lesson_type=course&amp;isPreview=0该URI为KEY链接的一部分，完整的KEY链接如下：https://edu.51cto.com/center/player/play/get-key?lesson_id&#x3D;151970&amp;id&#x3D;133999&amp;type&#x3D;course&amp;lesson_type&#x3D;course&amp;isPreview&#x3D;0&amp;sign&#x3D;9749dca5aea16534480f9ed26a082510多出来了一个sign参数，该参数在 获取视频信息里分析出来了。 取到Key字符串通过Key链接，访问后拿到Key字符串。需要将课程ID和Key字符串放在一起加密，得到新的字符串，再将该字符串进行转换成16进制字符串，便是真正的key了。 解密Key 上一步骤获取到的Key字符串并非最终，还需要搭配课程ID进一步解密。解密的格式：key字符串 + 课程ID该解密过程依赖于Js函数，由于函数过于冗长，转译成其他程序代码费时费力，推荐使用Python直接执行Js代码功能进行解密。 解密得到一串16位的字符串，还需要进行“16进制到文本字符串”的转码操作。可以使用在线工具转换，该工具的接口为：https://www.bejson.com/Bejson/Api/hexToString/toHexadecimal，POST请求参数：input，值为需要转码的字符串。也可以使用本地代码进行转码。 上一步完成后，就得到了最终的Key。剩下需要做的是利用Key进行AES解密TS文件，并输出未解密的TS文件。如何判断解密成功？通常加密过的TS文件是不能直接播放的，所以如果输出的新的TS文件能够正常播放则代表解密成功。 上面用到的JS代码，请跳转文末参考内获取## 解密TS文件：onKeyLoading关键函数，过于复杂，放弃 下载TS文件 解析M3U8文件，分割内部的文本，分割文本为\\n，以.ts进行匹配，匹配成功则代表TS下载链接 解析TS文件名 请求上一步链接，写入到文件，文件名为TS原始文件名 解密TS文件51某TO的收费视频，TS加密为AES-128-ECB，大部分网站是采用AES-128-CBC模式加密。至于免费视频没有尝试不了解。原计划通过python的库命令AES来进行解密。发现解密后无法播放，在耗费几个小时后放弃，如果有懂的同学还希望分享下你的方法。遂尝试使用OpenSSL 命令行解密，这需要在电脑上安装OpenSSL，并且配置好系统变量。具体解密步骤如下： 获取key字符串 获取到课程ID，链接里有 通过python第三方库execjs.compile(get_js())，来执行Js函数，将上述两个参数生成一个16位字符串。 将16位字符串转文本字符串，这里推荐使用下面的代码，亲测可用12345678def str_to_hexStr(string): ''' String to HEX Char String :string: The string to be converted :return: HEX Char String ''' str_bin = string.encode('utf-8') return binascii.hexlify(str_bin).decode('utf-8') 完成上述步骤后，就会得到用于解密TS文件的Key了 通过命令行调用OpenSSL，对加密的TS文件解密并输出新的未加密可直接播放的TS文件1start /min openssl aes-128-ecb -d -in \".\\video_ts_file\\old.ts\" -out \".\\video\\new_01.ts\" -K 534652324451534d3456313955554553 简单介绍一下上面的这行命令。start是cmd命令，启动某个程序。/min是后台最小化运行。 -d解密。-in输入文件的路径。-out输出文件的路径。-K用于解密的密码执行完毕后，TS文件将会正常播放。如若不能播放，请检查上面的KEY生成的参数是否正确。比如课程ID和你下载的视频的ID不一致，那也会导致解密失败。 合并视频合并视频可以用CMD自带的命令copy /b合并，前题是文件的命名是按照顺序排列的，否则合并的视频内容会错乱。也可以使用第三方开源的视频软件FFmpeg，我暂时不了解他们俩合并出来的视频有什么区别，我为了方便是使用CMD命令合并。CMD命令如下： 1copy /b .\\Download\\*.ts .\\Video\\new01.mp4 FFmpeg如下：bash .\\software\\ffmpeg.exe -f concat -safe 0 -i %home%cache\\filelist.txt -c copy %home%video\\test.mp4 filelist.txt是记录着需要合并的ts文件路径，内部格式大概长这样 ： 123file 'E:\\下载\\51_video_download_20210110\\video_ts_file\\new_loco_video_306000_0.ts' file 'E:\\下载\\51_video_download_20210110\\video_ts_file\\new_loco_video_306000_1.ts' file 'E:\\下载\\51_video_download_20210110\\video_ts_file\\new_loco_video_306000_2.ts' 遇到的问题 python通过AES-128-ECB解密不成功，目前使用OpenSSL解密，很麻烦，体验也不好，会有黑窗弹出来 结语难点在于几个加密的JS，这需要反调试JS，过程繁琐且枯燥，感谢前人。 上面提到的是通过M3U8来下载视频。如果你想更省事一点，可以想办法抓取页面的所有课程链接和标题，存储到文本内进行分割。这样就可以全自动下载了。 参考1.51CTO学院视频下载和解密 - t2.re","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"https://blog.gobyte.cn/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.gobyte.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"pure主题valine留言板添加：昵称、邮箱必填必写功能","slug":"pure主题valine留言板添加：昵称、邮箱必填必写功能","date":"2020-05-22T12:47:06.000Z","updated":"2023-10-07T08:53:25.035Z","comments":true,"path":"post/e56fdb88.html","link":"","permalink":"https://blog.gobyte.cn/post/e56fdb88.html","excerpt":"","keywords":null,"text":"起因很多网友在留言的时候，懒得去添加自己的邮箱，导致即使我回复对方也无法收到通知，所以需要给留言板的邮箱字段增加必填的功能。 解决留言板使用的valine，该插件提供了必填的配置项，但是我使用的pure主题由于作者没有更新，所以对该功能不支持。下面开始对pure主题进行修改： 找到文件pure\\layout\\_script\\_comment\\valine.ejs，替换如下代码： 12345678910111213141516171819202122232425262728293031&lt;% if (typeof(script) !== 'undefined' &amp;&amp; script) &#123; %&gt; &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt; &lt;script src=\"//cdn.jsdelivr.net/npm/valine\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var GUEST = ['nick', 'mail', 'link']; var meta = '&lt;%= theme.comment.valine.meta %&gt;'; meta = meta.split(',').filter(function(item) &#123; return GUEST.indexOf(item) &gt; -1; &#125;); var requiredFields = '&lt;%= theme.comment.valine.requiredFields %&gt;'; requiredFields = requiredFields.split(','); new Valine(&#123; el: '#vcomments', verify: &lt;%= theme.comment.valine.verify %&gt;, notify: &lt;%= theme.comment.valine.notify %&gt;, appId: '&lt;%= theme.comment.valine.appid %&gt;', appKey: '&lt;%= theme.comment.valine.appkey %&gt;', placeholder: '&lt;%= theme.comment.valine.placeholder %&gt;', avatar: '&lt;%= theme.comment.valine.avatar %&gt;', meta: meta, pageSize: '&lt;%= theme.comment.valine.pageSize %&gt;' || 10, visitor: &lt;%= theme.comment.valine.visitor %&gt;, requiredFields: requiredFields, &#125;); &lt;/script&gt;&lt;% &#125; %&gt; 在你的主题配置文件_config.yml的valine配置区增加配置：requiredFields: [&#39;mail&#39;,] #设置必填项。完整截图如下： 结束至此，配置已经完成。可以通过：hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，本地预览一下。","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]},{"title":"error:Missmatchins image and device刷机报错解决方法","slug":"error-Missmatchins-image-and-device刷机报错解决方法","date":"2020-05-06T14:28:21.000Z","updated":"2023-10-07T08:53:25.035Z","comments":true,"path":"post/5613105b.html","link":"","permalink":"https://blog.gobyte.cn/post/5613105b.html","excerpt":"","keywords":null,"text":"起因在我尝试给小米6进行线刷的时候，miFlash工具报错：error:Missmatchins image and device。从字面上理解是我的刷机包下载的不对，不是小米6的刷机包。实际上刷机包是正确的，而且我的手机也解锁了bootloader。 解决在我百思不得其解的时候，我只能按照线刷的流程，下载了解锁工具，然后在关机状态下按：音量下键+锁屏键，进入：bootloader模式。我个人是通过adb命令进入：adb reboot bootloader 打开解锁工具登陆你的小米账号进行解锁，这个小米账号务必要和你手机登陆的账号一致。不出意外的话，解锁软件会提示你的手机已经解锁，无需再解锁。 提醒：如果你手机没有解锁bootloader，解锁会导致丢失数据，建议使用“小米助手“进行备份数据到电脑 解锁成功了，再去miFlash点击“加载设备”，如果能正常显示设备，选择好底部的数据保留模式，我选择的是保留用户数据，因为我是线刷升级到某个版本，如果你不需要保留，可以选“全部删除”。 经过了416秒，我这边刷机成功并自动重启。 问题也得到了解决。 个人猜测之所以造成这样的情况，可能是在系统升级，或者刷机成功后手机内的解锁标记失效了，导致miFlash认为你没有解锁或者其他的原因，所以只需要通过解锁工具走一遍流程即可，如果确实早就解锁了，再次解锁的时候是不会丢失数据的。","raw":null,"content":null,"categories":[{"name":"设备","slug":"设备","permalink":"https://blog.gobyte.cn/categories/%E8%AE%BE%E5%A4%87/"}],"tags":[{"name":"手机","slug":"手机","permalink":"https://blog.gobyte.cn/tags/%E6%89%8B%E6%9C%BA/"}]},{"title":"解决微软EDGE浏览器在线大声朗读语音卡顿问题","slug":"解决微软EDGE浏览器在线大声朗读语音卡顿问题","date":"2020-03-15T15:22:25.000Z","updated":"2023-10-07T08:53:25.040Z","comments":true,"path":"post/46726573.html","link":"","permalink":"https://blog.gobyte.cn/post/46726573.html","excerpt":"","keywords":null,"text":"新版的Chromium内核的edge浏览器添加了一个语音朗读的功能，配合F9的沉浸式阅读体验非常好，朗读效果堪比真人，测试语音链接：测试语音 问题但是使用过程中发现朗读时会经常卡顿，我猜测是网络原因导致，原因是我发现我使用的是“xiaoxiao”的女生online为在线朗读，搜索后发现使用的是微软云服务的神经网络合成的语音，所以对网络有要求。 再加上大陆对国外服务器延迟过高、丢包等问题，所以也情有可原。 解决交代了问题后，猜测是网络问题，最简单的方法就是利用科学上网，减少延迟和丢包。 添加需要科学上网的域名：speech.platform.bing.com 通过浏览器打开步骤1的域名，使用浏览器的：开发者工具-network，抓包测试这个域名是否成功科学上网。或者使用“大声朗读”的“xiaoxiao”等语音测试，是否还会继续卡顿。 最终结果如下图： 这个域名已经走我本地代理服务器成功的科学上网了，此时我的大声朗读也不会再频繁的卡顿，到此问题解决。 结语通过ip138查询发现，该域名确实指向的境外服务器，所以该问题符合我的猜想，确实是因为大陆对境外服务器的访问导致网络延迟、丢包问题，如下图：","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"https://blog.gobyte.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://blog.gobyte.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"海信A5自动开机打卡微信通知结束关机","slug":"海信A5自动打卡自动微信通知自动开机自动关机","date":"2020-02-29T13:48:42.000Z","updated":"2023-10-07T08:53:25.039Z","comments":true,"path":"post/e6505ee3.html","link":"","permalink":"https://blog.gobyte.cn/post/e6505ee3.html","excerpt":"","keywords":null,"text":"# 须知 海信A5自动打卡、微信通知需要依托于“阅读小子”App，具体请看：海信A5自动阅读打卡签到工具软件脚本APK 电脑一台用于开启无障碍权限。阅读小子依托于“无障碍模式”实现，但是由于Android的一些特性，导致“无障碍模式”会在关机后失效，所以开机又需要手动打开，非常繁琐。所以如果想要实现自动开机打卡，需要解决“无障碍模式”一直是处于打开的状态 自动关机依托于海信A5的定时关机功能，自动开机是借助手机闹钟的功能 解决方案开机自动打开无障碍模式 安装Tasker，安装包在群文件中 进入无障碍，将“阅读小子”、“tasker”的无障碍功能打开 进入：设置-关于手机-重复点击”内核版本“，直至显示“您已处于开发者模式……” 进入：设置-其它设置-开发者选项-USB调试，勾选 电脑下载ADB文件，通过CMD执行ADB命令：adb shell pm grant net.dinglisch.android.taskerm android.permission.WRITE_SECURE_SETTINGS 打开Tasker-配置文件-点击+号-输入一个名字“自动打开无障碍模式”-事件-输入“设备启动”-返回-新建任务-直接点击√确认-筛选器输入“自定义系统设置” 类型选择：安全。在名称的右侧单击放大镜-选择设置-筛选器里输入enabled_accessibility_services。不出意外，最终只有一个选项，而且一大串英文，大胆的点击它 正确的设置如下图 点击右上角返回，再返回一次，最终退到了Tasker的“配置文件”的界面，点击“放大镜”左侧的√保存 此时，开机自动打开无障碍模式已经成功，如果你还是不会操作，请跟着这位男主播一起操作，不过他使用的是英文版：Tasker配置讲解：开机自动打开无障碍开关 设置启动阅读小子 打开tasker-任务，右下角加号，新建任务：《启动脚本》，然后点击√确认 进入“启动脚本”后，右下角加号-筛选器“结束应用”-选择“阅读小子”-左上角返回 继续添加，筛选器“等待”-拖动秒的进度条，我选择8秒-左上角返回 继续添加，右下角加号-筛选器“启动应用”-选择“阅读小子”-左上角返回 最终设置效果如下图 添加自动启动任务 tasker-配置文件-右下角添加-0点打卡-时间，将“至”单击，直至右侧没有时间 在“从”的右侧，拖动你需要启动“阅读小子”的时间，例如我设置的是：0点5分，如下图 单击右上角的箭头，返回 此时会弹框，让你选择一个任务，此时我们应该选择上一个环节新建的《启动脚本》任务 单击右上角的√保存设置，最终Tasker的配置文件设置如下图 须知 阅读小子、Tasker在QQ群文件：获取，早期进群免费，目前进群收费9.9元&#x2F;台手机 如果认为文字版教程晦涩难懂，请跟着这位男主播一起操作，不过他使用的是英文版：Tasker配置讲解：开机自动打开无障碍开关 如果你还有其他的问题，欢迎留言，当然如果能付费进群，自然更好了","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.gobyte.cn/categories/JavaScript/"}],"tags":[{"name":"AutoJs","slug":"AutoJs","permalink":"https://blog.gobyte.cn/tags/AutoJs/"}]},{"title":"困扰5年的K1K2pk3华硕padavan不能定时crontab命令执行的问题终于解决","slug":"困扰5年的华硕padavan不能定时crontab命令执行的问题终于解决","date":"2020-02-29T01:53:42.000Z","updated":"2023-10-07T08:53:25.037Z","comments":true,"path":"post/59785a2c.html","link":"","permalink":"https://blog.gobyte.cn/post/59785a2c.html","excerpt":"","keywords":null,"text":"缘起​ 大概2015年，跟风上了斐讯的车，屯了不少的K1&#x2F;K2路由器。后来斐讯什么情况大家都知道，比较幸运的是最后2个斐讯的产品由京东自营兜底了，所以我不但没有赔钱，还小赚了一点以及斐讯的路由器设备。 ​ 由于斐讯路由器市场保有量大，从而有很多第三方的固件可供安装。就我而言，安装过潘多拉、华硕老毛子、华硕荒野无灯、华硕Hiboy、高恪。现在在持续更新的还有Hiboy、高恪的固件。高恪我不喜欢用，性能不够好。Hiboy只在telegram发布了，而其他的作者已经不再更新甚至下架了，原因我问过H大，他表示因为固件里带了一些“科学上网”，所以在2019年只要包含了“科学上网”的固件全部下架，这些都是题外话，不过多叙述。 ​ 在体验众多固件中，最稳定的就是潘多拉，但是界面和设置繁琐以及没有相应的插件，我不喜欢用它，但是够稳定，该有的功能都能正常使用，比如我最喜欢的Crontab定时功能，我常用来给路由器进行重启。 ​ 但是我装上华硕的固件后，用了几年，从来就没有Crontab定时成功过，由于近期迫切需要该功能，我只能重头到位尝试。 开始解决测试思路 重新安装其他的固件，好在硬盘里有几年前的华硕固件 恢复出厂设置，测试Crontab命令 联系Hiboy作者 测试结果 第一种思路，无效。原因是重新安装其他的固件，不会重置用户的数据，这也是后来才知道为什么无效的 第二种思路。刚恢复后定时命令可以成功，但是当我导入用户配置文件后，立即失效 Hiboy作者同样不知道原因 进一步思考 既然恢复出厂设置后成功，那么我是不是可以手动设置路由器，而不是直接导入以前的路由器配置文件？ 既然要手动设置路由器，那么我应该每次修改设置后，通过Crontab定时命令输出一些内容，比如打印日志，来证明我修改设置后还是可以定时执行的 操作方法 我准备了一个定时命令，以修改WiFi为例子： 1* * * * */bin/echo -路由器定时测试：修改2.4g WiFi名和密码`date` &gt;&gt; /home/root/time.txt &amp; 这个shell命令需要写在：自定义设置 - 脚本 - 自定义 Crontab 定时任务配置 内 它的作用是每间隔1分钟，用echo命令向：&#x2F;home&#x2F;root&#x2F;time.txt 文件写入一段字符串，同事路由器配置页面也会显示log记录 当我配置WiFi以后，我在：自定义设置 - 脚本 - 自定义 Crontab 定时任务配置，填入上面的内容，最后保存配置 等待log输出内容，华硕固件的log查看方法是在右上角，有一个Log按钮 每配置一个内容后，就对shell命令内的测试内容进行修改，直到我设置路由器用户名后，定时命令不再生效 此时我的路由器用户名里有一些符号“.”，一个英文的点，这是不支持特殊符号，还是不允许修改默认的用户名？ 为此，我将用户名内的符号删除，仅适用：数字+字母 的组合 测试结果表明，华硕固件的用户名不支持用户名带有特殊符号，为此困扰我5年的问题终于得到解决 总结 如果某个功能之前正常，在做了某些操作后失效，就需要恢复曾做过的操作 如果操作的内容太多，建议恢复出厂设置，一步步来操作 用户名不应该使用特殊符号，建议：字母+数字 的组合 路由器的固件通常是一个裁剪过的Linux系统，有不完善的地方很正常。请仔细Google搜索，有可能别人遇到和你一样的问题，耐心一点测试，毕竟能靠得住的人还是你自己","raw":null,"content":null,"categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.gobyte.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://blog.gobyte.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}]},{"title":"Google gcloud 执行命令不允许连接不上问题设置代理解决方案","slug":"Google-gcloud-执行命令不允许连接不上问题设置代理解决方案","date":"2020-02-27T03:01:09.000Z","updated":"2023-10-07T08:53:25.030Z","comments":true,"path":"post/undefined.html","link":"","permalink":"https://blog.gobyte.cn/post/undefined.html","excerpt":"","keywords":null,"text":"问题原因gcloud执行命令后，无法进如下一步，通常是因为在大陆不能连接Google服务器导致的。 解决方案很简单，找一个能连接Google代理，设置gcloud代理即可。 解决方法 gcloud config list 查询当前的配置 我一开始连接gcloud的时候，提示让我设置一个代理，我这个代理ip以及端口都是正常的，对应的我本机的v2ray软件。但是一直连接不成功，原因是下面的type错误了。v2ray的type &#x3D; socks5。所以这时我应该修改这个type类型为socks5 gcloud config set proxy/type socks5，CMD里输入这个命令，即设置成功。 gcloud components list命令，联网测试下看看能不能获取服务器的组件列表从上图看到，数据是成功的，说明此时命令可以执行了。 我是要安装alpha组件，所以我执行命令:gcloud components install alpha 一顿操作猛如虎，组件安装成功，问题解决。 总结 思考为什么不能执行命令？猜测是谷歌的服务器连接不上。 如何连接谷歌的服务器？代理！V2ray本地端口的代理协议是socks5，如果是其它软件，你可以试试sockes4，或者http","raw":null,"content":null,"categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.gobyte.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://blog.gobyte.cn/tags/Shell/"}]},{"title":"ant-design由svg图片自定义icon图标引申出来的问题","slug":"ant-design由svg图片自定义icon图标引申出来的问题","date":"2020-01-10T06:04:37.000Z","updated":"2023-10-07T08:53:25.034Z","comments":true,"path":"post/4570a123.html","link":"","permalink":"https://blog.gobyte.cn/post/4570a123.html","excerpt":"","keywords":null,"text":"起因在开发前端项目的过程中，难免会使用自定义的图片作为icon使用。传统的icon是直接通过css或者img标签来嵌入到页面中。那么React项目中使用了ant Design前端组件开发该如何操作？ 操作查阅antd说明，自定义图标需要一个Svg格式的图片。SVG是矢量图，所谓矢量图你只需要简单的理解为这种图不管你怎么放大或者缩小，它不会失真，不会有马赛克。最主要的是SVG可以通过代码来描绘图像，可以通过任何的文本编辑器来打开修改编辑图片。 所以我们需要做如下准备： svg图片一张 复制svg图片的文本代码到Js中 封装成一个自定义的React标签 最终代码如下： 123456789101112131415161718192021import React, &#123; Component &#125; from 'react'import &#123; Icon &#125; from 'antd';export default class HeartIcon extends Component &#123; HeartSvg = () =&gt; ( &lt;svg width=\"1em\" height=\"1em\" fill=\"currentColor\" viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9z\"/&gt; &lt;/svg&gt; ); render() &#123; const HeartIcon = props =&gt; &lt;Icon component=&#123;this.HeartSvg&#125; &#123;...props&#125; /&gt;; return ( &lt;HeartIcon style=&#123;&#123; color: 'hotpink' &#125;&#125;/&gt; ) &#125;&#125; 最终会渲染一个粉红色的小心： 自定义ICON如何操作？上面这些比较简单，这个心形的svg图片是官方提供的，所以比较顺利，问题就在于我们自己的svg。 在起因我简单介绍过SVG它是用代码来描述图形的，在UI设计师通过AI导出SVG的时候，有几种选项，如下图： 我的UI设计师提供给我的svg格式是这样的： 在预览的时候，没毛病，显示的很正常。 但是当我们把这里所有的svg代码复制到js中，将会报错： 其实主要报错的原因在于这个style标签。这里的内容在js中属于书写格式不匹配，从而导致报错语法错误。 解决方法仔细观察这个style标签里面的内容，其实它就是CSS样式。我们只需要把style标签样式移动到下面的标签内，改成行内样式，并且去除冗余的标签，只要能保证svg最终可以正常显示即可，如下图： 最终效果： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142/** ICON自定义图标-2020年1月10日10:40:43-山岚-blog.gobyte.cn* */import React, &#123; Component &#125; from 'react'import &#123; Icon &#125; from 'antd';export default class CloudConnected extends Component &#123; CloudConnectedSvg = () =&gt; ( &lt;svg width=\"2em\" height=\"2em\" viewBox=\"0 0 33.6 33.6\"&gt; &lt;circle cx=\"16.8\" cy=\"16.8\" r=\"16.3\" fill='none' stroke='#1890ff' strokeMiterlimit='10'/&gt; &lt;path d=\"M30.55,21.49h-.06a5.08,5.08,0,0,0-2.25-5.07,4.72,4.72,0,0,0-3.11-1.06l-.31,0-.44,0A5,5,0,0,0,22,16a4.7,4.7,0,0,0-2.72,3.67,4.45,4.45,0,0,0-3.34,2.46,5.07,5.07,0,0,0,.62,9.7c.53.13,1.33.35,1.66.42a26.42,26.42,0,0,0,2.82.42,28.92,28.92,0,0,0,4.29.25,20.69,20.69,0,0,0,4.09-.58,4.63,4.63,0,0,0,1.5-.45,4.12,4.12,0,0,0,.74-.45C37,30.33,36.61,21.49,30.55,21.49Z\" transform=\"translate(-7.9 -7.96)\" fill='#1890ff'/&gt; &lt;path d=\"M18.32,27.55,21.27,30a1.54,1.54,0,0,0,2.12,0,1.51,1.51,0,0,0,0-2.12l-2.95-2.48a1.54,1.54,0,0,0-2.12,0,1.52,1.52,0,0,0,0,2.12Z\" transform=\"translate(-7.9 -7.96)\" fill='#fff'/&gt; &lt;path d=\"M23.61,30.25l5.59-5.8c1.34-1.39-.78-3.51-2.12-2.12l-5.59,5.8c-1.34,1.39.77,3.52,2.12,2.12Z\" transform=\"translate(-7.9 -7.96)\" fill='#fff'/&gt; &lt;/svg&gt; ); HeartSvg = () =&gt; ( &lt;svg width=\"1em\" height=\"1em\" fill=\"currentColor\" viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9z\"/&gt; &lt;/svg&gt; ); render() &#123; const CloudConnectedIcon = props =&gt; &lt;Icon component=&#123;() =&gt; &lt;this.CloudConnectedSvg/&gt;&#125; &#123;...props&#125; /&gt;; const HeartIcon = props =&gt; &lt;Icon component=&#123;this.HeartSvg&#125; &#123;...props&#125; /&gt;; return ( &lt;div&gt; &lt;HeartIcon style=&#123;&#123; color: 'hotpink' &#125;&#125;/&gt; &lt;CloudConnectedIcon/&gt; &lt;/div&gt; ) &#125;&#125;","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"AntD的一个警告解决方法-defaultvalue is invalid for getfielddecorator will set value please use option.initialvalue instead","slug":"AntD的一个警告解决方法：defaultvalue-is-invalid-for-getfielddecorator-will-set-value-please-use-option-initialvalue-instead","date":"2019-12-07T08:58:03.000Z","updated":"2023-10-07T08:53:25.029Z","comments":true,"path":"post/7080982b.html","link":"","permalink":"https://blog.gobyte.cn/post/7080982b.html","excerpt":"","keywords":null,"text":"症状控制台报错截图： 点击提示后会展开详细信息： 错误原因根据报错的提示语得知，在设置默认值的时候，应该使用：option.initialValue，而不是直接使用：defaultValue 错误代码： 1234567getFieldDecorator('name', &#123; rules: [&#123; required: true, message: '请输入姓名!' &#125;], &#125;) ( &lt;Input defaultValue=\"测试\" value=\"测试\" /&gt;, )&#125; 正确代码： 12345678getFieldDecorator('name', &#123; rules: [&#123; required: true, message: '请输入姓名!' &#125;], initialValue: \"你需要设置的默认值\", &#125;) ( &lt;Input /&gt;, )&#125; 如何解决？在展开报错详情的第四行，就是我代码有问题的地方，详细如下： 1234567891011121314151617181920212223242526272829&#123; getFieldDecorator( item.name, &#123; rules: item.rules, initialValue: defaultValue &#125; ) ( &lt;RadioGroup buttonStyle=\"solid\" onChange=&#123;item.onChange&#125; //组件里不应该设置默认值，如果需要设置应该在：initialValue里设置 defaultValue=&#123;item.defaultValue&#125; &gt; &#123; item.options.map( item =&gt; &lt;Radio key=&#123;item.value&#125; onChange=&#123;item.onchange&#125; value=&#123;item.value&#125; checked=&#123;item.checked&#125; &gt; &#123;item.text || item.value&#125; &lt;/Radio&gt; ) &#125; &lt;/RadioGroup&gt; )&#125; 所以我只需要把defaultValue={item.defaultValue}这张注释即可。 总结本问题不难，以为我看到这一大串的报错提醒都会选择略过，然后使用搜索引擎苦苦搜索。事实上只要多观察报错提醒，就可以很简单的解决问题。","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"海信A5自动阅读打卡签到工具软件脚本APK","slug":"海信A5自动阅读打卡签到工具软件脚本","date":"2019-12-06T09:03:39.000Z","updated":"2023-10-07T08:53:25.039Z","comments":true,"path":"post/cbc43a97.html","link":"","permalink":"https://blog.gobyte.cn/post/cbc43a97.html","excerpt":"","keywords":null,"text":"敬告本软件为本人学习研究使用，产生一切法律后果、损失本人一概不承担责任，如被海信封号取消活动资格等不可预期的问题。使用本软件代表同意该约定，如不同意请勿下载安装并使用。 软件介绍该软件服务于海信的A5墨水屏手机，因为该手机早期有一个活动，就是阅读180天，每天30分钟且阅读300页，并点击“打卡”按钮，则会返还购机款。因此，该工具应运而生。 软件基于autoJs开发，打包成apk运行，软件无广告、无病毒、绿色，目前有以下特性： 开机自启动并执行（需要特殊设置） 启动后关闭屏幕背光节省电量，退出前自动恢复 自动检测是否完成任务，并决定是否需要阅读 识别当前是否正常阅读状态，否则会给予报警 模拟人工点击屏幕随机延时点击，随机坐标屏幕 阅读完成或者遇到问题会锁定屏幕，避免长时间亮屏损耗电量 完成或者有错误能截图并通过微信发送消息提示当前手机的状态 当书籍阅读完成会尝试向前翻页—尚未实现 使用说明 长按悬浮窗可以拖动悬浮窗位置 长按“开始&#x2F;停止”按钮3秒钟，可以关闭悬浮窗 自动锁屏；软件自动锁屏是利用系统提供的快速锁屏的功能，需要自己手动打开。路径：设置→智能辅助→动作与手势→双击状态栏熄屏 注意： 新版本京东阅读无法完成任务，建议降级，Q群里有免升级的修改版，我使用的是1.15.0。目前可以在豌豆荚下载所有的历史版本-京东读书老旧版本大全_所有历史官方版安装下载_豌豆荚 为了保证能够正常使用本软件，请在安装成功后勾选“信任本软件”.。如果你打算启用微信通知，那么需要请你授权“屏幕截图”，因为微信通知是会包括你打卡成功的截图，示例 下载地址海信A5自动打卡工具-蓝奏下载 下载地址里面还有一个《海信禁用App列表.txt》，这个是停用海信A5自带App的列表。其中包括“系统升级”、“系统跟踪”等自带的App，你可以通过Adb命令停用，也可以不操作，不影响本软件使用。 提醒：禁用自带App会导致部分系统功能无法正常使用，请慎重。 常见问题 蓝奏云里App禁用列表要禁用了才能用软件打卡吗？ 答：下载地址里面还有一个《海信禁用App列表.txt》，这个是停用海信A5自带App的列表，其中包括“系统升级”、“系统跟踪”等自带的App，你可以停用，也可以不操作，不影响本软件使用。 为什么我开启微信通知以后就不能启动了？ 答：没有授予权限导致的。建议“清空应用所有数据”后重试，或者卸载后重装，在安装成功的界面勾选“信任本软件”。实在不行请卸载重装，给足所有权限。 新版本京东阅读不能用呢？ 答：是的。京东阅读应该从1.15.1，将不会把自动点击的阅读时间和阅读页面，不纳入任务的统计。所以为了能够正常使用本软件打卡，建议降级京东阅读，历史版本的京东阅读地址见上方内容。 出厂自带的京东阅读版本号是多少？ 答：不权威答案，出厂自带的京东阅读是1.14.0 如何反馈问题？ 你可以直接添加阅读小子官方QQ群反馈：，目前群需要付费进入，价格9.9元","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.gobyte.cn/categories/JavaScript/"}],"tags":[{"name":"AutoJs","slug":"AutoJs","permalink":"https://blog.gobyte.cn/tags/AutoJs/"}]},{"title":" AutoJs获取的Text文本是乱码|Android爬虫反字体屏蔽乱码解决方案 ","slug":"AutoJs获取的Text文本是乱码解决方案","date":"2019-11-23T03:50:19.000Z","updated":"2023-10-07T08:53:25.029Z","comments":true,"path":"post/ae3d322e.html","link":"","permalink":"https://blog.gobyte.cn/post/ae3d322e.html","excerpt":"","keywords":null,"text":"源由AutoJs可以获取Android原生的空间，比如TextView里的文字。实践中发现，大部分的textView是可以正常获取到文本的，但是某些App做了防止爬取的功能，将TextView的字体设置为冷僻的字体，导致即使被获取了文本，也无法正常的显示出来，俗称“乱码”。针对这种问题，我自己另辟途径发现了一个比较完美的解决方案。 方案的原理较为简单，适用性也比较广。通过反编译Apk文件，获取内部的资源，例如字体文件.ttf。得到ttf字体文件以后，可以安装到Windows系统上，然后从手机里复制出无法识别的字体，保存到文本文件，最后把文本文件放在Windows上使用Notepad打开，设置Notepad的字体格式为这个冷僻的字体，正常情况下是可以显示的。 但是需要注意的是，虽然Windows是可以显示这个特殊的字体，但是你可能依然无法输入这个字体。虽然Windows能够轻松安装字体文件，但是Android程序基本是安装不了的。即使安装了，很有可能其他文字例如汉字就会显示乱码。因为你安装的冷僻字体并不一定包含了汉字。就以我这个字体为了，它是在阿里巴巴矢量图库：icon-font自定义矢量图ico生成的ttf字体文件，这个文件内只有字母和阿拉伯数字，所以如果我把这个字体强行安装在Android上，很有可能出现我上面的猜测。而且我也不愿意去安装这个字体。 解决原理既然Android系统上无法通过安装字体来解决识别问题。那么我们是不是可以尝试自己做一个字体映射，以此来识别文字内容呢？将乱码通过手工在代码里定义成一个常量，表示这个乱码的内容。 例如：1 = #45d 2=#hd2……以此类推，其中45d 和hd2都是乱码。那么我怎么知道乱码是什么？还记得上面复制出来的文本文件吗？虽然现在可以正常显示，但是它在Android系统中就是乱码。学过计算机系统的朋友应该知道，所有的文件最终是以二进制的形式保存在硬盘上，所以虽然我们看起来乱码，但是它的二进制内容是不会丢的。 因此，我们可以选择以二进制来查看这个文本文件，即可找到这个字符对应的二进制内容，如下图，我通过十六进制查看文本文件： 其实上图有误导性。因为记事本打开的这个文件和用editplus打开的文件不是同一个文件。记事本打开的“字体测试”是修改后的，而editplus打开的“字体测试”不是最新的，这是前提。 当editplus里的光标放在十六进制区域的31上面的时候，右边十进制的区域1被选中了，说明十六进制的31是等于十进制的1，为什么这样？因为这是使用了ASCII码表，具体如下图： 从ASCII码表中可以看到字符&#96;1&#96;&#96;的十进制是编码是49，把49转成十六进制刚好是31，如下图： 由此可知31确实等于字符串1，恰好和右边的十进制区域内的1对应了。 而0A则是对应着换行符，不信的话可以查找上面的ASCII码表，换行符的编码是10，10转十六进制为0A。 那么31左边的3位是什么？聪明的朋友可能想到了，这就是那个特殊字体，在这个“字体测试”文件中，我用数字1和换行符来做分割，从数字0~9依次列举出来了。所以在31 0A的左边3位十六进制，代表着一个特殊字体的数字。 所以由此可以知道：EE A4 8E便等于0，EE A4 8F等于1，EE A4 90等于2，EE A4 91&#96;等于3……以此类推一直到9。所以我们只需要读取特殊字体的文本，然后转行成十六进制，再和上面的字符串进行比对就知道特殊字体的文本的含义了，是不是很简单？ 改进一下另外如果你观察的足够仔细的话，三位十六进制，前两位是不变的，变动的只是第三位，所以如果实际上09的十个数字的十六进制是：8E + 10，8E的十进制&#x3D;142。142 + 10 &#x3D; 152。152的十进制是98。所以09的特殊字体的十六进制的区间是：8E~98。 编码既然十六进制的含义都解决了，剩下就是编码了。编码思路如下： 读取特殊字体的文本 将文本转换成十六进制 将十六进制的位数&#x2F;3，因为每3位代表一个数字 根据上面解析的十六进制对照表，来判断出字符串应有的含义","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.gobyte.cn/categories/JavaScript/"}],"tags":[{"name":"AutoJs","slug":"AutoJs","permalink":"https://blog.gobyte.cn/tags/AutoJs/"}]},{"title":"GitHub克隆clone太慢添加代理加速访问","slug":"GitHub克隆clone太慢添加代理加速访问","date":"2019-11-13T03:51:13.000Z","updated":"2023-10-07T08:53:25.030Z","comments":true,"path":"post/1a22163b.html","link":"","permalink":"https://blog.gobyte.cn/post/1a22163b.html","excerpt":"","keywords":null,"text":"GitHub由于不可描述的原因，克隆clone非常非常慢，此时如果你有个提子可以按下面的方法解决方法一，全局代理（不推荐）下面是你提子的本地代理端口，我的端口是10808，打开git base窗口，复制下面的2行命令粘贴即可 12git config --global http.proxy socks5://127.0.0.1:10808git config --global https.proxy socks5://127.0.0.1:10808 取消 12git config --global --unset http.proxygit config --global --unset https.proxy 方法二，只针对部分域名代理（推荐）上述方法挂了全局代理，但是如果要克隆码云、coding等国内仓库，速度就会很慢。更好的方法是只对github进行代理，不会影响国内仓库： 12git config --global http.https://github.com.proxy socks5://127.0.0.1:10808git config --global https.https://github.com.proxy socks5://127.0.0.1:10808 教程结束","raw":null,"content":null,"categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.gobyte.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.gobyte.cn/tags/Git/"}]},{"title":"奇葩公司每周晚上占用下班时间开会、团建（跑步）","slug":"奇葩公司每周晚上占用下班时间开会、跑步","date":"2019-11-11T06:36:16.000Z","updated":"2023-10-07T08:53:25.038Z","comments":true,"path":"post/d90e4430.html","link":"","permalink":"https://blog.gobyte.cn/post/d90e4430.html","excerpt":"","keywords":null,"text":"背景介绍广东拓斯达科技全资子公司，深圳市拓联智能信息技术有限公司。我在该公司担任软件开发，正常工作时间是早9，中午12点，下午1.30到18点下班，大小周。我从8月入职，一直到10月基本每天都是21点下班。后来技术领导说希望大家不要无意义加班当天工作计划完成就早点下班，此时我才从10月中旬开始偶尔准点下班了。虽然如此，我那些同事基本都不会准点下班依然在公司加班。可能是因为他们都是刚毕业，不敢下班太早吧。 关于加班据说鼓励加班的人是总经理徐必业提出来的。而徐毕业是从华为公司辞职出来的，看来网上传言华为“狼性文化”所言不虚。悲哀的是，不是华为的命得了华为的病。华为的高收入，我想只要是从事IT行业的人都知道。而我们的薪资水平是远远低于华为的这个水平的。不可谓要想马儿跑，还不想给马儿吃草。好在上司对他这个观点不认可，让我们自己规划好工作就下班。虽然常规加班可以不加了，但是每周一晚上的代码评审开会还一直存在，最早的时候会在21点20下班。最迟的时候我经历过22:40下班。偶尔不定期的某个晚上还搞个“通识学习”，这一切都是项目经理“马亮”提出来的，学习是我支持的，但是强迫下班时间学习我是非常不认可。但是迫于现实，只能妥协。 关于团建面试的时候还不知道没周三晚上还有集体跑步，感觉回到了校园时光。这个跑步时间是在19点30分，步行至深圳市宝安体育馆，差不多8点30分离场。 起初我是跟着大家一起参加，直到有一次因为要回请朋友吃饭，在周三的时候提前和产品经理请假后被告知要“捐款”10元后，我就再也不去参加了。大概有三周没有没有参加，项目经理马亮就开始约我谈话。主旨是让我继续参加每周三网上的跑步活动。一开始我真以为是关心下属身体健康，我真诚的回复我会跑步的。后来谈话中才发现他真正的意图是让同事在下班时间多沟通、多交流、促进团队感情、增加团队之间的工作效率，至于锻炼身体都是次要的。 结语写本文的目的有几点： 宣泄内心的情绪 让更多人知道广东拓斯达科技全资子公司，深圳市拓联智能信息技术有限公司公司的真实情况 希望公司不要占用员工休息时间，员工也是人，想要元工替公司卖命就把钱给足 希望我以后不再进入这种公司 谢谢你的阅读，祝你生活愉快。","raw":null,"content":null,"categories":[{"name":"心情","slug":"心情","permalink":"https://blog.gobyte.cn/categories/%E5%BF%83%E6%83%85/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"https://blog.gobyte.cn/tags/%E5%90%90%E6%A7%BD/"}]},{"title":"React使用andt的table翻页按钮不更新的问题","slug":"React使用andt的table翻页按钮不更新的问题","date":"2019-11-07T09:22:00.000Z","updated":"2023-10-07T08:53:25.032Z","comments":true,"path":"post/f54c318f.html","link":"","permalink":"https://blog.gobyte.cn/post/f54c318f.html","excerpt":"","keywords":null,"text":"起因使用相同的table组件，相同的参数，结果一个页面可以正常显示翻页效果。另一个能正常显示翻页数据，翻页的按钮不会改变。代码如下： 12345678910const Data = &#123; //这个是table内展示的数据 list: list, //这个就是翻页参数 pagination: &#123; total, pageCurrent, pageSize &#125;,&#125;; 不完美的解决具体原因最终没找到，但是通过查阅Andt的文档，得知翻页的当前页码变量名为cureent,而非使用pageCurrent。于是我将不正常页码的翻页参数对象改为如下： 123456789const Data = &#123; list: list, //分页；current: pagination: &#123; total, current : pageCurrent, pageSize &#125;,&#125;; 页码立马就正常的。当我将正常页码的：pageCurrent数据也改为：current : pageCurrent。原本正常的页面却开始报错了，报错如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445backend.js:6 Warning: Failed prop type: Invalid prop &#96;current&#96; of type &#96;function&#96; supplied to &#96;Pagination&#96;, expected &#96;number&#96;. in Pagination (created by Context.Consumer) in LocaleReceiver (created by Pagination) in Pagination (created by Context.Consumer) in div (created by Context.Consumer) in div (created by Context.Consumer) in Spin (created by Context.Consumer) in div (created by Context.Consumer) in Table (created by SimpleTable) in div (created by SimpleTable) in div (created by SimpleTable) in SimpleTable (created by order) in div in div in Unknown (created by order) in order (created by Connect(order)) in Connect(order) (created by AsyncComponent) in AsyncComponent (created by Route) in Route (created by TIndexPage) in Switch (created by TIndexPage) in div (created by TIndexPage) in div (created by Basic) in Basic (created by Context.Consumer) in Adapter (created by TIndexPage) in div (created by BasicLayout) in BasicLayout (created by Context.Consumer) in Adapter (created by TIndexPage) in div (created by Scrollbars) in div (created by Scrollbars) in Scrollbars (created by TIndexPage) in div (created by BasicLayout) in BasicLayout (created by Context.Consumer) in Adapter (created by TIndexPage) in div (created by BasicLayout) in BasicLayout (created by Context.Consumer) in Adapter (created by TIndexPage) in TIndexPage (created by Connect(TIndexPage)) in Connect(TIndexPage) (created by Route) in Route in Switch in Router (created by HashRouter) in HashRouter in LocaleProvider in Unknown in Provider 上面报错我的理解是： Pagination需要一个Number类型的属性，而不是function类型。所以我只能将current删去便恢复正常。 具体为什么一个页面使用current值就会变成function，另一个页面使用则依然是Number类型无法得知了，先记录一下，以后能想到原因再来更新，或者有知道的朋友也可以留言回复。","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"Ajax请求XMLHTTPRequest请求返回GBK编码中文乱码解决方法","slug":"Ajax请求XMLHTTPRequest请求返回GBK编码中文乱码解决方法","date":"2019-10-26T01:43:52.000Z","updated":"2023-10-07T08:53:25.028Z","comments":true,"path":"post/6258b05e.html","link":"","permalink":"https://blog.gobyte.cn/post/6258b05e.html","excerpt":"","keywords":null,"text":"前言当我通过跨域Ajax请求京东的商品库存接口时，返回的中文出现了乱码。有意思的是，当我多次请求尝试时，返回提会改变，并且返回的编码也会改变，所以偶尔会返回一个UTF-8的返回体。示例的请求接口如下： http://c0.3.cn/stocks?callback=getStockCallback&amp;type=getstocks&amp;skuIds=32399605916&amp;area=15_1213_1214_0&amp;1572054766314 skuIds 商品的id getStockCallback 回调函数；可以使用这个名字来编写一个回调处理函数 area 地区编码；需要查询库存的地区 正常的请求如下，会乱码： ! 可是当多次请求以后，返回体会发生改变，并且中文也能显示了： 解决方法1.全局查找中文判断由于第一种返回体中文是乱码的，起初我第一种判定方法是查找有无“现货”和“无货”两种关键词。例如我想查询“现货”，代码如下： 123if (r.responseText.indexOf( '现货' ) &gt; 0) &#123; alert( '现货' );&#125; 但是这种方法比较蠢。原因有下几点： 每次返回中不一定都是中文，即使“有货”，也不一定是中文显示 当“有货”时，但是不是中文，代码还一直以为无货。时间过去了以后很有可能被他人购买了，即使“有货”也真的会变成“无货” 2.使用Script的标签来完成跨域以及GBK解码使用&lt;script&gt;标签来跨域请求；因为浏览器的同源策略限制，请求非当前页码的域名的时候，会被浏览器阻止，但是&lt;script&gt;标签受此影响。其实Ajax的跨域请求也是利用该原理。但是，&lt;scprit&gt;标签的优点是可以设置编码格式，也就是说即使后台返回了GBK编码，我们照样能够得到中文字符串，下面是代码示例： 12345678910111213141516//检查库存function checkStock() &#123; //创建一个script对象 var script = document.createElement( 'script' ); //设置请求地址 script.src = 'http://c0.3.cn/stocks?callback=getStockCallback&amp;type=getstocks&amp;skuIds=32399605916&amp;area=15_1213_1214_0&amp;1572054766314' + new Date().getTime(); //设置GBK编码 script.charset = 'gbk'; //将script对象添加到dom中 document.body.appendChild( script ); //错误时触发事件；当请求服务器返回错误代码时，会自动调用该事件 script.onerror = function () &#123; //错误时重复执行本身函数 checkStock(); &#125;&#125; 其实光有一个请求函数还是不够的。我们还需要编写一个回调函数来处理返回值。这里啰嗦几句，很多新人对这个玩意理解不够很容易造成困扰，包括我之前也是这样。所谓回调函数个人理解是：当向服务器发送请求成功以后，我们会定义一个函数来进行处理。也就是：返回后调用函数，简称回调函数。 回调函数是定义在请求链接中，也就是上面URL参数里的：callback=getStockCallback，那么函数名就是：getStockCallback，我的回调函数如下： 1234567891011121314151617181920//回调函数function getStockCallback( data ) &#123; //取出数据 for (var sk1 in data) &#123; console.log( data[sk1]['StockStateName'] ); var productStockStatus = data[sk1]['StockStateName']; var stockState = data[sk1]['stockState']; console.log( 'productStockStatus=', productStockStatus, 'stockState=', stockState ); &#125; //判断是否有货 if (productStockStatus !== '无货') &#123; alert( 'Baby! 现在有货了！快买！' ); window.clearTimeout( t1 ); &#125; else &#123; window.clearTimeout( t1 ); //设置定时执行 t1 = window.setTimeout( checkStock, 3 * 1000 ); &#125;&#125; 至此，该代码就能完整的解析GBK编码了 3.意外发现，不需要判断中文也能知道库存状态其实，在我编码的过程中发现，能不能解析中文不重要，因为在返回体重已经有一个字段已经表明了库存状态了，请参考以下代码： 123456789101112//判断状态var stockName = '';if (stockState === 33) &#123; stockName = '现货';&#125; else if (stockState === 39 || stockState === 40) &#123; stockName = '有货';&#125; else if (stockState === 36) &#123; stockName = '预定';&#125; else &#123; stockName = '无货';&#125;console.log( 'stockName=', stockName ); 所以如果只需要监测库存的话，判断下这个stockState字段就可以了。 其它解决方法 GBK编码下jQuery Ajax中文乱码终极暴力解决方案；我未尝试 我依然希望能找到Ajax 解码GBK方法，因为script标签还是有些繁琐。","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.gobyte.cn/tags/JavaScript/"}]},{"title":"React不同环境使用不同配置：开发、内网、外网、客户","slug":"React不同环境使用不同配置：开发、内网、外网、客户","date":"2019-10-18T09:33:53.000Z","updated":"2023-10-07T08:53:25.032Z","comments":true,"path":"post/fbb1b617.html","link":"","permalink":"https://blog.gobyte.cn/post/fbb1b617.html","excerpt":"","keywords":null,"text":"起因实际开发中一个项目需要多个版本，不同版本之间的参数各不相同，举例说明：1. 开发版：需要有报错信息显示；需要使用本机服务器；需要使用本机mock功能2. 内网版：开发完成以后，部署到内网服务器供其他同事查看。测试，需要用内网服务器数据库3. 外网版：测试正常以后，发布到外网服务器，给客户展示。需要用外网服务器数据库。4. 客户版：项目需要持续性的解决bug，以及部署到客户的服务器。需要用客户内网服务器数据库以上四个版本都需要使用不同的参数重复的说明了一个项目需要不同版本的情况。通常在上面情况发生时，是手动的去修改配置信息，然后就是build生成静态文件。 这样不仅繁琐、累，还更容易出错。因为当客户火急火燎的催你改完bug以后，你大概率的情况下会直接build然后上传部署了。等你花了时间部署以后测试，你缺发现页面加载是空白的，原因就是因为你build的时候没有修改配置信息，导致部署后项目不正常。 另外在尝试了几种教程以后，无法达到效果，最终花费3小时才成功，菜到自己不忍直视，所以下决心记录解决方案，为后来者提供一下参考。 解决方法安装cross-env的插件：1npm install --save-dev cross-env 当您像那样使用NODE_ENV&#x3D;production设置环境变量时，大多数Windows命令提示符都会阻塞。(Windows上的Bash是个例外，它使用本机Bash。)类似地，windows和POSIX命令利用环境变量的方式也有所不同。使用POSIX时，使用:$ENV_VAR，在windows上使用%ENV_VAR%。 一句话概括插件作用：解决Window和Linux系统之间环境变量不通用的问题。 你还可以看视频学习，具体可以在视频2：35秒的处：webpack-dev-server的配置和使用 插件地址：cross-env - npm 准备参数配置文件文件名随意，我自己是：processENV.js 123456789101112131415161718192021222324252627&#x2F;***************************************************************** * Copyright (C), 2017-2019, *******有限公司 * FileName: processENV.js * Version: 0.1 * Author: Zhou Liang * Date: 2019-10-18 5:13 PM * TODO: 本文件是用来区分开发环境、内网环境、外网环境、索特内网的作用 *****************************************************************&#x2F;&#x2F;&#x2F;读取数据const NODE_ENV &#x3D; process.env.APP_ENV;&#x2F;&#x2F; const NODE_ENV &#x3D; &#39;start&#39;;const config &#x3D; &#123; start: &#123; API_CONFIG: &#39;start&#39; &#125;, production: &#123; API_CONFIG: &#39;production&#39; &#125;, devmes: &#123; API_CONFIG: &#39;devmes&#39; &#125;, soot: &#123; API_CONFIG: &#39;soot&#39; &#125;&#125;;console.log( &#39;config[\\&#39;start\\&#39;]&#39;, config[NODE_ENV]);module.exports &#x3D; config[NODE_ENV]; 配置DefinePlugin()传值打开WebPack配置文件webpack.base.config.js 再引入上面准备好的文件：const processENV = require( &#39;./processENV&#39; ); 然后编写代码，下面这段代码是在： 12345new webpack.DefinePlugin( &#123; 'process.env': &#123; APP_ENV: JSON.stringify( processENV ), &#125;&#125; ), webpack.base.config.js文件是配置在package.json的start{}代码块中，如下： 123456789\"scripts\": &#123; \"start\": \"cross-env APP_ENV=start webpack-dev-server --config ./scripts/webpack.dev.config.js\", \"build\": \"cross-env APP_ENV=production webpack --config build/webpack.config.js\", \"build-devmes\": \"cross-env APP_ENV=build-devmes webpack --config ./scripts/webpack.prod.config.js\", \"build-soot\": \"cross-env APP_ENV=build-soot webpack --config ./scripts/webpack.soot.config.js\", \"lint\": \"eslint ./ --cache --fix --ignore-pattern .gitignore\", \"mock\": \"supervisor -i node_modules mock/http.js\", \"test\": \"cross-env APP_ENV=production\"&#125;, 关键：传值不论是启动，还是build，其实都是执行package.json文件里面的scripts代码块的命令，而传值就是在这里配置。 固定格式：cross-env APP_ENV&#x3D;start start：就是传入的值 APP_ENV：就是在其它JS文件里的取值变量 最终效果在JS文件里调用： 1console.log( 'process.env.APP_ENV', process.env.APP_ENV ); 浏览器输入的效果： 参考教程 webpack-dev-server的配置和使用 使用DefinePlugin通过NODE_ENV配置环境变量 NODE_ENV和webpack 以及QQ群友 flipped(675576674) 的热心帮助 安利最后安利一下自己开发油猴子脚本-掘金版面优化：掘金界面宽屏布局-山岚 更多油猴子脚本，可以进我的个人页面索取：山岚的GreasyFork主页","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"React部署到Nginx后图片404错误问题解决方法","slug":"React部署到Nginx后图片404错误问题解决方法","date":"2019-09-10T05:46:17.000Z","updated":"2023-10-07T08:53:25.034Z","comments":true,"path":"post/b53e48df.html","link":"","permalink":"https://blog.gobyte.cn/post/b53e48df.html","excerpt":"","keywords":null,"text":"React的路由模式路由配置是一组命令，用来告诉Router如何匹配URL以及匹配后如何执行代码，而不会去请求服务器，所以作用和计算机网络的交换机路由功能类似：根据某个条件，做某个事情。 React路由模式有五种： BrowserRouter：浏览器的路由方式，也就是在开发中最常用的路由方式 HashRouter：在路径前加入一个“#”成为一个哈希值，Hash模式的好处是，再也不会因为刷新而找不到页面而导致404 MemoryRouter：不存储Histor，所有路由过程保存在内存中，不能进行前进和后退，因为地址栏没有发生任何变化 NativeRouter：经常配合ReactNative使用，多用于移动端 StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用 React常用的路由模式有两种：1.BrowserRouter：优点的是路径里不带#号，缺点是刷新会导致404，可以通过在服务器端配置反向代理解决该问题 服务器端反向代理解决方案： 12345678910111213141516171819 server &#123; listen 80; server_name localhost; #防止React路由后，刷新页面404 #定义根目录为html文件夹，这里也可以切换成React的打包文件夹dist #root D:/nginx-1.17.3/html; root E:/SRC/iotintroduction/dist; #我这里使用的是build后的dist文件夹，因为我是先在Windows上测试，测试没问题再上传到服务器。这样的好处是每次修改后就不用再复制到Nginx的HTML文件夹内。 index index.html; location / &#123; try_files $uri /index.html; &#125; #映射图片 location /css/img/ &#123; alias E:/SRC/iotintroduction/dist/img/; #autoindex on; &#125;&#125; 2.HashRoter：缺点是路径有#号，非常难看。优点是不需要反向代理，也可以随便刷新。 总结：在开发测试阶段，推荐使用HashRouter，这样可以避免每次修改页面后刷新404的问题。等产品上线之前，再修改为BrowserRouter，配合Nginx等反向代理工具即可。","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"从现在开始提升认知力，走出思维误区，改变自己的人生","slug":"提升认知力，，走出思维误区，改变自己的人生","date":"2019-08-25T07:46:57.000Z","updated":"2023-10-07T08:53:25.038Z","comments":true,"path":"post/dda6bca9.html","link":"","permalink":"https://blog.gobyte.cn/post/dda6bca9.html","excerpt":"","keywords":null,"text":"误区一：确认偏误确认偏误，就是人们总倾向于寻找证据来支持我们已经相信的事情，抵制不同的看法。 看到同事指出自己的错误，就觉得同事在排挤自己，还找出了不少同事排挤自己的“证据”哪怕对方很有可能只是就事论事； 觉得爱人不喜欢自己了，那看什么都觉得对方变了心，对方迟点回信息也一定是变心了，而不是因为对方工作实在很忙。 请记住一句话，你看到的往往只是你想看到的。当你带着情绪去看待问题，往往就是掉进认知的陷阱里。 误区二：达克效应达克效应（D－Keffect），全称为邓宁－克鲁格效应（Dunning－Krugereffect），指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论。 通俗点解释，就是谢博德博士说的：“总有一些人认为自己什么都懂，或者低估自己不懂的事情。” 简单来说就是：自己不行又不承认，还觉得别人也不行。 真正的知识，是要知道一个人无知的程度。 傻瓜认为自己是明智的，而聪明人则认为自己是个傻瓜。 很多事情，真的没我们想得那么简单，多一分尊重，不要老是自以为什么都懂。 倘若总是觉得自己很厉害、别人很糟糕，那其实是忽视了自己的缺失和薄弱，永远不可能有提高的可能。 一个人什么时候最难提升自我？当他觉得自己已经足够好的时候。 不要让达克效应，阻碍了你向上生长的道路。 误区三：认知失调谢博德博士在演讲中说了一个故事： 2017年飓风哈维登陆美国得克萨斯州休斯顿市，3天之内降雨50英寸，整个城市都陷入了一片汪洋之中。 但在飓风登录前一周，谢博德博士就已经反复提醒休斯顿市民：根据观察，这次飓风到来可能会造成40到50英寸的降雨量。 即便如此，市民们依然无所作为，并在一周后迎来了洪灾，造成了重大损失。 为什么会这样？ 休斯顿当地虽然经常下雨，但之前全年的降雨量也才34英寸。 谢博德博士所预言的“短时间内降雨40到50英寸”，已经超过了休斯顿市民能够理解的范围——几天之内就下完一整年的雨？这怎么可能！ 因为和自己过去的经验发生冲突，所以休斯顿市民说得最多的一句话就是：我看到了预警，但没想到真的会这么糟糕。 这就是谢博德博士说的“认知失调”： 新信息与已有的信念相矛盾，无法理解现有经验外的事物的时候，会让人产生失调的感觉，这种感觉会驱使一个人去寻找合理化的解释，让自己的认知达到一致。 认知失调 休斯顿的市民就是这样，他们面对无法理解的新信息，就去找一个合理化的解释，觉得灾情不会那么糟糕，忽视科学家的警告，最后造成重大损失。 试想一下，这样的情况，在生活中实在太常见了： 很多爱抽烟的人明知抽烟不好，却很自信地认为“虽然抽烟有害健康，但是不会发生在我的身上”，哪怕咳嗽不断也不愿意停下来。 但很显然，这种态度妨碍了我们看清楚世界的真面目，让我们始终带着滤镜去看待这个世界，不愿去改变自己的行为，最后自会被现实狠狠教育一顿。 认知半径，决定了一个人能力的大小那么如何摆脱这3种思维误区的影响，走出思维上的认知框架？ 谢博德博士提出了一个“认知半径”原理，他把人的认知范围比作一个圆圈，认知的半径越大，人的认知范围也就越大。 认知半径，决定了一个人能力的大小。 那么，应该如何扩大自己的认知半径？谢博德博士给出了3个方法： 1、列出自己的偏见回忆一下，自己曾经存在的种种偏见，比如地域歧视、比如性别歧视、比如看待问题的主观…然后思考一下，它们到底从何而来，由什么形成的？——你的养育过程、你的学习过程、你的信仰、你的成长轨迹… 想要不被偏见影响，首先要看到自己存在着哪些偏见。 2、评估信息来源每一次从外界接受到一个信息，不要先急着认同这个信息，而是先问一下自己，这个信息从何而来的？这些信息的来源，到底有没有权威性？ 3、表达出来你可以和朋友、家人谈谈，评价自己过去的偏见，以及这些偏见是怎么形成的，谈谈你如何评估你的偏见和信息来源，并可以试着分析它们是如何影响自己的认知的。 人生是无数次选择的结果，选择的好坏直接造成了今天我们的现状。 而大部分的选择，都没有一个准确的答案，只能靠我们的认知能力去判断。 因为，不是人生选择了你，而是你选择了人生。 你的浏览器不支持Video标签视频 J·马歇尔·谢博德TED演讲视频 参考自：知乎万赞，这个被分享100万次的演讲，再度刷新我对世界的认知！","raw":null,"content":null,"categories":[{"name":"变得更好","slug":"变得更好","permalink":"https://blog.gobyte.cn/categories/%E5%8F%98%E5%BE%97%E6%9B%B4%E5%A5%BD/"}],"tags":[{"name":"思维改变","slug":"思维改变","permalink":"https://blog.gobyte.cn/tags/%E6%80%9D%E7%BB%B4%E6%94%B9%E5%8F%98/"}]},{"title":"React入门学习--如何完整的设计一个应用组件-持续更新中","slug":"React入门学习-完整的设计一个应用组件-持续更新中","date":"2019-08-22T07:37:11.000Z","updated":"2023-10-07T08:53:25.033Z","comments":true,"path":"post/261b7f71.html","link":"","permalink":"https://blog.gobyte.cn/post/261b7f71.html","excerpt":"","keywords":null,"text":"引言 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。 来自官网-React哲学 先试想一下，如果让你做一个数据搜索表格页面，你会怎么做？草图如下： Json数据： 12345678&#123;category: '体育用品', price: '$49.99', stocked: true, name: 'Football'&#125;,&#123;category: '体育用品', price: '$9.99', stocked: true, name: 'Baseball'&#125;,&#123;category: '体育用品', price: '$29.99', stocked: false, name: 'Basketball'&#125;,&#123;category: '电子产品', price: '$1080', stocked: true, name: 'Hasee'&#125;,&#123;category: '电子产品', price: '$1000', stocked: true, name: 'Huawei'&#125;,&#123;category: '电子产品', price: '$99.99', stocked: true, name: 'iPod Touch'&#125;,&#123;category: '电子产品', price: '$399.99', stocked: false, name: 'iPhone 5'&#125;,&#123;category: '电子产品', price: '$199.99', stocked: true, name: 'Nexus 7'&#125; 设计流程 设计组件的原则；根据json数据，创建组件。如果你学过其它的编程语言，可以把组件理解为函数或者是对象，然后根据单一功能原则来判定组件的范围。说人话就是一个组件它应该只负责一个功能。如果你的组件需要有很多的功能，则应该把该组件拆封成更小的组件，然后把它组装起来变成你想要的功能。 上图中一共有五种颜色的方法，它代表五个组件。 最上级的组件FilterableProductTable (橙色): 是整个例子应用的整体 搜索框SearchBar(蓝色)：接收用户输入的数据 商品表ProductTable(绿色)：用来暂时商品的列表以及筛选后的列表 产品分类的标题ProductCategoryRow (天蓝色): 为每一个产品类别展示标题 商品ProductRow (红色): 每一行展示一个产品 其中商品表ProductTable的Name和Price没有独立成一个组件。这只是一种偏好，就本例子来说，因为表头只是起到渲染数据结合的作用，所以这个于ProductTable是一致，所以仍然把它保留为ProductTable的一部分。但是如果你的表头过于复杂，例如有筛选、排序、数据导出等功能，那么应该把它独立成一个TableHeader组件就非常有必要了。 层级划分如下： FilterableProductTable 可以过滤的表单 SearchBar 搜索栏 ProductTable 商品展示表 ProductCategoryRow 商品类别的标题 ProductRow 商品 先使用React创建一个静态版本的页面，最容易的方法是先创建一个不含交互功能的UI界面。最好将UI和交互这两个过程分开设计。原因是编写静态页面版本的时候，需要编写大量的代码，而不需要考虑过多的细节；而添加交互功能的时候，则需要考虑大量的细节，而不需要编写太多的代码。所以，将这两个过程分开更为合适。 在构建静态版本时，需要创建一些会重用的组件，然后就涉及到数据的传递。数据传递有props和state，而props是父组件向子组件传递数据的方式。即使你熟悉了state的概念，也完全不应该使用state构建静态版本。state代表了随时间会产生变化的数据，应该在实现交互时使用。所以构建静态应用的时候，不要使用它。 在构建应用时，可以采用自上而下，或者自下而上构建应用。自上而下意味着首先编写层级较高的组件（比如本文中的FilterableProductTable ）。自下而上意味着从最基本的组件开始编写（比如ProductRow组件）。当你的应用比较简单时，使用自上而下方式更为方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。 由于目前只需要构建一个静态版本的应用，所以我们的组件只需要提供render()方法用于渲染即可。最顶层的组件FilterableProductTable 通过props接收数据参数。如果你的数据模型发生了变化，则再次调用ReactDOM.render()，UI就会相应的更新。数据模型变化、调用Render()方法、UI就会相应变化。React的单向数据流（单向绑定）的思想使得组件模块化，易于快速开发。 state 和 props 之间的区别是什么？props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。 下面是一些不错的资源，可以用来进一步了解使用 props 或 state 的最佳时机： Props vs State ReactJS: Props vs. State 确定需要使用的State 使用State有一个原则，只保留应用所需要的可变的State，其它的数据由他们计算而出。例如你编写一个任务清单应用，应该用一个数组来保存所有事情，而不要再定义一个State保存任务个数。当需要任务个数的时候，应该使用数组的length属性即可。 本例子有如下的几个数据： 所有产品的列表 用户输入的关键字 复选框是否被勾选 经过筛选后的产品列表 现在需要通过下面的三个问题，来判断是否需要使用State存储： 该数据是否通过props父组件传递来的？如果是的话，那么它不应该使用State存储。 该数据是否会随着时间的推移而保持不变？如果是的，那么它也不应该使用State 你能否通过其他的props或者state计算出该数据？如果是话，那么它也不是使用State 包含所有产品的列表，它是由父组件的props传入。所以它不是State，如下： 123&lt;ProductTable products&#x3D;&#123;this.props.products&#125;&#x2F;&gt; 搜索词和复选框应该使用State，因为它们无法由其它数据计算，而且会随着时间改变 123456&#x2F;&#x2F; 保存搜索关键字handleFilterTextChange(filterText) &#123; this.setState(&#123; filterText: filterText &#125;)&#125; 123456&#x2F;&#x2F; 保存复选框状态handleInStockOnlyChange(inStockOnly) &#123; this.setState(&#123; inStockOnly: inStockOnly &#125;)&#125; 经过筛选后的列表，是可以由原始产品列表和搜索词和复选框计算出来的，所以它不应该使用State 综上所述，属于State有： 用户输入的搜索词 复选框是否选中的值 确定State存放的位置 现在已经在第三步的时候确定了使用哪些State了。接下来，我们还需要确定哪些组件改变了这些State，或者说拥有这些State。 注意：React中的数据流都是单向的。所谓单向是指不管是父组件或是子组件，都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。而且它顺着组件层级从上往下传递。 所以哪个组件拥有State的问题，对于初学者来说比较难以理解，尽管如此但是还是可以通过下面的几个步骤来判断： 对于应用中的每一个State： 找到根据这个State进行渲染的所有组件 找到他们的共同的父组件 他们的共同父组件或者比这个共同父组件层级更高，应该拥有这个State 如果你找不到一个合适的组件来存放State，那么就直接创建一个新的组件来存放该State，并将这个新组建位置高于共同所有者组件层级的位置 根据以上五个步骤，我们例子的State位置判断的结果如下： ProductTable需要根据State筛选产品列表。SearchBar需要展示搜索词和复选框状态 他们俩共同的父组件是FilterableProductTable 所以，搜索词和复选框的值应该很自然的放在FilterableProductTable组件中 根据上面三个步骤，我们已经决定了把State存放在FilterableProductTable组建中。因此我们需要开始添加State了： 将 this.state = {filterText: &#39;&#39;, inStockOnly: false} 添加到FilterableProductTable的construtor中设置初始值。 1234567constructor(props) &#123; super(props); this.state &#x3D; &#123; filterText: &#39;H&#39;, inStockOnly: false &#125;&#125; 将 filterText 搜索关键词和 inStockOnly 复选框勾选作为 props 传入 ProductTable 和 SearchBar 123456789101112131415return ( &lt;div&gt; &lt;SearchBar filterText&#x3D;&#123;this.state.filterText&#125; inStockOnly&#x3D;&#123;this.state.inStockOnly&#125; onFilterTextChange&#x3D;&#123;this.handleFilterTextChange&#125; onInStockOnlyChange&#x3D;&#123;this.handleInStockOnlyChange&#125; &#x2F;&gt; &lt;ProductTable products&#x3D;&#123;this.props.products&#125; filterText&#x3D;&#123;this.state.filterText&#125; inStockOnly&#x3D;&#123;this.state.inStockOnly&#125; &#x2F;&gt; &lt;&#x2F;div&gt;); 最后，用这些 props 筛选 ProductTable 中的产品信息，并设置 SearchBar 的表单值。 添加反向数据流 在做这件事之前，先要明白一个概念，什么是反向数据流？前面我们学过，目前React可以通过props和State传值。但是State是只能是某个组件内使用，其它的组件也不知道State里有什么内容，这个称为单向数据流。所以，现在如果其它的组件想读取或者修改这个State的值，就称为反向数据流了。概要的说：反向数据流是处于较低层级的表单组件，需要更新较高层级的FilterableProductTable中的State中 React通过一种比传统的双向绑定更加繁琐的方法来实现反向数据传递。尽管如此，但这种显示声明的方法更有助于人们理解程序的运作方式。 如果你在这时尝试在搜索框输入或勾选复选框，React不会产生任何的响应。这个是正常的，因为我们之前已经将Input的值设置为从FilterableProductTable的State传递而来的“固定值” 重新梳理一下需要实现的功能： 每当用户改变表单的值，我们需要改变State来反映用户的当前输入。 由于State只能由拥有它的组件进行更改，那么FilterableProductTable 必须要提供一个触发State改变的回调函数onInStockOnlyChange(callback)传递给SearchBar。然后可以在SearchBar的输入框中使用onChange事件来监听用户的输入变化，并通知FilterableProductTable传递给SearchBar的回调函数onInStockOnlyChange 该回调函数，将会调用setState()，从而更新应用 源代码地址带注释的源代码：https://gist.github.com/shanlanCoding/ba8b016e871b22ce505c7aa6696d7bb1 在线演示地址：https://codepen.io/gaearon/pen/LzWZvb","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"React入门学习--状态提升","slug":"React入门学习-状态提升","date":"2019-08-21T01:22:17.000Z","updated":"2023-10-07T08:53:25.033Z","comments":true,"path":"post/6b4a429b.html","link":"","permalink":"https://blog.gobyte.cn/post/6b4a429b.html","excerpt":"","keywords":null,"text":"什么是状态提升？官网是这样解释的： 通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。 我对“状态提升”的理解是，子组件A和子组件B需要进行数据交换&#x2F;共享，则需要把他们俩需要交换数据的变量temp，放在他们最近的共同父组件内创建。这样，这两个子组件都可以访问到temp变量，并且还可以对temp变量进行修改。 说人话，“状态提升”可以帮你解决不同组件之间的赋值问题。 详细代码执行流程1.首先React先挂载Calculator组件。而Calculator组件会调用render()渲染页面UI2. Calculator组件的render()内定义一些变量接收数据。其中用到了三元表达式来调用温度单位换算或者赋值12345678&#x2F;&#x2F; 页面初始值const scale &#x3D; this.state.scale;const temperature &#x3D; this.state.temperature;&#x2F;&#x2F; 如果是f，就调用tryConvert()进行温度换算，否则赋值temperature给scaleconst celsius &#x3D; scale &#x3D;&#x3D;&#x3D; &quot;f&quot; ? tryConvert(temperature, toCelsius) : temperature;const fahrenheit &#x3D; scale &#x3D;&#x3D;&#x3D; &quot;c&quot; ? tryConvert(temperature, toFahrenheit) : temperature; 3.在Calculator组件的render()内的**return()**有三个组件。A. 两个输入框组件：TemperatureInput1. TemperatureInput输入框组件需要接收3个参数：scale温度符号、temperature温度数值、onTemperatureChange调用哪个温度单位转换函数12345678910111213141516171819return ( &lt;div&gt; &#123;&#x2F;* 传入摄氏度 传入摄氏度函数 *&#x2F;&#125; &lt;TemperatureInput scale&#x3D;&quot;c&quot; temperature&#x3D;&#123;celsius&#125; onTemperatureChange&#x3D;&#123;this.handleCelsiusChange&#125; &#x2F;&gt; &lt;TemperatureInput scale&#x3D;&quot;f&quot; temperature&#x3D;&#123;fahrenheit&#125; onTemperatureChange&#x3D;&#123;this.handleFahrenheitChange&#125; &#x2F;&gt; &lt;BoilingVerdict celsius&#x3D;&#123;parseFloat(celsius)&#125; &#x2F;&gt; &lt;&#x2F;div&gt;); 2. 在render()内接受父组件Calculator的值，例如温度temperature，以及onChange事件执行函数12345678910111213render() &#123; &#x2F;&#x2F; 接收父组件传递来的温度数值 const temperature &#x3D; this.props.temperature; &#x2F;&#x2F; 接收温度标识符。如c或者f。C是摄氏度，F是华氏度 const scale &#x3D; this.props.scale; &#x2F;&#x2F; 输入框，带有onChange处理函数 return ( &lt;fieldset&gt; &lt;legend&gt;请输入温度 &#x2F; &#123;scaleNames[scale]&#125;&lt;&#x2F;legend&gt; &lt;input value&#x3D;&#123;temperature&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt; &lt;&#x2F;fieldset&gt; );&#125; 3. 该组件的render()会渲染出一个输入框1234567891011121314render() &#123; &#x2F;&#x2F; 接收传递来的温度数值 const temperature &#x3D; this.props.temperature; &#x2F;&#x2F; 接收温度标识符。如c或者f。C是摄氏度，F是华氏度 const scale &#x3D; this.props.scale; &#x2F;&#x2F; 输入框，带有onChange处理函数 return ( &lt;fieldset&gt; &#x2F;&#x2F; scaleNames[]数组里是存放华氏度和摄氏度的全称，如 c: &quot;Celsius&quot; &lt;legend&gt;请输入温度 &#x2F; &#123;scaleNames[scale]&#125;&lt;&#x2F;legend&gt; &lt;input value&#x3D;&#123;temperature&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt; &lt;&#x2F;fieldset&gt; );&#125; 4. 上面的input框有一个onChange事件，调用了handleChange()方法，代码如下：123456handleChange(e) &#123; &#x2F;&#x2F; 调用父组件的handleCelsiusChange方法。而handleCelsiusChange方法是由父组件内的this.handleCelsiusChange提供的。 &#x2F;&#x2F; 而this.handleCelsiusChange是保存数据的作用，最终该数据会被tryConvert()方法调用，来做温度单位转换 &#x2F;&#x2F; 这行代码是调用父组件的onTemperatureChange()方法，然后传入当前输入框的value值，也就是用户输入的数字 this.props.onTemperatureChange(e.target.value);&#125; 在input输入框里输入数字的时候，会实时把value传入到 this.props.onTemperatureChange(e.target.value)并调用。而onTemperatureChange()实际上在调用handleCelsiusChange()来保存用户输入的数据到state内。 12345678&#x2F;&#x2F; 保存 摄氏度 数据handleCelsiusChange(temperature) &#123; this.setState(&#123; scale: &quot;c&quot;, temperature &#125;);&#125;&#x2F;&#x2F; 保存 华氏度 数据handleFahrenheitChange(temperature) &#123; this.setState(&#123; scale: &quot;f&quot;, temperature &#125;);&#125; 例如在handleCelsiusChange(temperature)的temperature就是 B. 一个提供沸腾信息显示的BoilingVerdict，判断celsius是否大于等于1001234567&#x2F;&#x2F; 是否是开水function BoilingVerdict(props) &#123; if (props.celsius &gt;&#x3D; 100) &#123; return &lt;p&gt;水开了&lt;&#x2F;p&gt;; &#125; return &lt;p&gt;水还没有沸腾&lt;&#x2F;p&gt;;&#125; 总结 React挂载组件&lt;Calculator /&gt; &lt;Calculator /&gt;里，定义了初始值温度、温度单位、温度转换函数，以及渲染了2个输入框，1个文本提示。初始值均为空字符串 给输入框组件&lt;TemperatureInput /&gt;传递了三个参数：scale、temperature、onTemperatureChange。这三个参数初始值默认为空 scale： 温度的单位；初始值为空，后续根据用户在哪个输入框里输入，来赋值。 temperature： 已经计算好温度；初始值空字符串，后续根据用户的输入框来赋值。 onTemperatureChange： 调用父组件的handleCelsiusChange方法。而handleCelsiusChange方法是由父组件内的this.handleCelsiusChange提供的。而this.handleCelsiusChange是保存数据的作用，最终该数据会被tryConvert()方法调用，用来做温度单位转换。其中这个参数重中之重，因为该参数准确的作用是将父组件的方法传递给子组件调用，从而实现了子组件向父组件赋值的功能，也就是所谓的状态提升 完整代码完整注释：https://gist.github.com/shanlanCoding/725bc0b068f359e29f6e1bf31a1019cc 在线演示： https://codepen.io/gaearon/pen/WZpxpz 效果图","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"使用脚本批处理让Hexo一键部署和推送到远程仓库","slug":"使用脚本批处理让Hexo一键部署和推送到仓库","date":"2019-08-19T07:52:31.000Z","updated":"2023-10-07T08:53:25.037Z","comments":true,"path":"post/69d4d350.html","link":"","permalink":"https://blog.gobyte.cn/post/69d4d350.html","excerpt":"","keywords":null,"text":"缘由通常Hexo博客程序需要使用命令进行生成然后再部署到服务器，如果备份博开程序的话，还需要使用Git进行push操作，异常的繁琐。为此，我将利用脚本功能，来实现自动化操作，降低重复劳动。 操作方法 新建txt记事本文件：deployHexo.cmd 将以下批处理代码粘贴到你刚建立的txt内，然后根据你的实际情况进行修改，下面是Hexo 的deploy部署脚本 1234@echo offD: ::切换到你hexo程序所在的磁盘，例如我是在D盘cd D:\\GitHub_Pages\\Hexo-git\\shanlancoding.github.io ::切换到你Hexo程序的完整目录hexo g -d &amp;&amp; mshta vbscript:msgbox(\"部署完成，准备push源程序到仓库\",6,\"部署完成\")(window.close) &amp;&amp; color 4 &amp;&amp; call pushHexo.cmd ::这一行其实有四条命令，通过&amp;&amp; 符号连接起来执行 下面是把Hexo源程序通过Git push到远程仓库的批处理脚本，也就是备份你的Hexo程序， 新建文件名：pushHexo.cmd保存 123456789@echo offset /p commit=commit:title auto commitcd C:\\Program Files\\Git\\bin\\git.exe add -Agit.exe commit -m %commit%git.exe pushecho 命令执行完毕，请按任意键关闭pause &gt;null 命令详解deployHexo.cmd 文件 @echo off 关闭不必要的批处理提示语 D: 切换到你hexo程序所在的磁盘，例如我是在D盘 cd D:\\GitHub_Pages\\Hexo-git\\shanlancoding.github.io 切换到你Hexo程序的完整目录 hexo g -d Hexo命令，生成静态页面文件 mshta vbscript:msgbox(&quot;部署完成，准备push源程序到仓库&quot;,6,&quot;部署完成&quot;)(window.close) 弹出Windows对话框，用于提示 color 4 修改控制台的字体颜色 call pushHexo.cmd 调用另一个批处理文件 pushHexo.cmd 文件 set /p commit=commit: 设置变量用来接收你输入的push描述 title auto commit 设置批处理窗口的标题 cd C:\\Program Files\\Git\\bin\\ 切换到你的Git.exe目录，注意是Git.exe，而不是git-bash.exe，由于我的Git本身安装在C盘，若你的安装在C盘以外，例如D盘，则在执行这条命命令之前还需要添加一条命令：D: git.exe add -A 添加所有变动的文件到本地Git暂存区 git.exe commit -m %commit% 将本地Git暂存区的文件提交给本地仓库，并且戴上了本次提交的描述 git.exe push 将本地仓库文件推送给远程仓库，可以理解为上传 echo 命令执行完毕，请按任意键关闭 批处理的提示语 pause &gt;null 让批处理界面暂停而不会自动关闭界面 使用方法 当你把两个文集都修改完成后，双击启动deployHexo.cmd文件后，批处理将会自动调用hexo generate 和 hexo deploy 当deployHexo.cmd文件执行完毕后，将会有一个系统弹窗来提醒你，输入一个push消息，然后就可以回车确认了","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]},{"title":"使用Git让HEXO多备份源程序到GitHub和Coding等网站","slug":"使用Git让HEXO多备份源程序到GitHub和Coding等网站","date":"2019-08-19T03:51:17.000Z","updated":"2023-10-07T08:53:25.036Z","comments":true,"path":"post/54986170.html","link":"","permalink":"https://blog.gobyte.cn/post/54986170.html","excerpt":"","keywords":null,"text":"为什么要这样操作？因为某些原因导致GitHub在国内的pull速度太慢了，所以我想着以后如果把代码push到国内的网站，这样初次pull项目的时候就非常的快。但是GitHub又比较常用，通常代码都是要push到GitHub上，所以如果能在push的时候，能同时push多个仓库就是极好的。 解决方法完整解决教程：一个项目push到多个远程Git仓库 我使用的是第二种方法。注意，如果远程仓库和本地版本不一致，我使用强制覆盖远程仓库。 操作步骤： 查询目前Git的远程仓库列表 123$ git remote -vorigin https://github.com/shanlanCoding/shanlancoding.github.io.git (fetch)origin https://github.com/shanlanCoding/shanlancoding.github.io.git (push) 添加需要备份的远程仓库URL git remote set-url --add 本地仓库名 需要push的新仓库地址 1git remote set-url --add origin git@git.dev.tencent.com:shanl/shanl.git 完整命令：1git remote set-url --add git@git.dev.tencent.com:shanl/shanl.git 再次查询远程仓库列表： 1234$ git remote -vorigin https://github.com/shanlanCoding/shanlancoding.github.io.git (fetch)origin https://github.com/shanlanCoding/shanlancoding.github.io.git (push)origin git@git.dev.tencent.com:shanl/shanl.git (push) 这时候我们发现多了一个链接，而这个就是我们刚添加进入的。另外还有链接后面的括号，里面有push和fetch两种参数。fetch代表我们pull的地址，也就是我们上传代码到哪个仓库的地址，一般fetch地址只生效一个，即使多个也只使用第一个fetch地址。 我最初在添加新的远程仓库地址后，发现了我的fetch地址替换成新的仓库地址了，所以我还需要修改fetch的地址，具体解决方法参考这里：Git 修改远程仓库URL，添加Fetch&#x2F;Pull的URL的解决方法 | 山岚 - 90码农历险记","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.gobyte.cn/tags/Git/"}]},{"title":"Git 修改远程仓库URL，添加Fetch/Pull的URL的解决方法","slug":"Git-修改远程仓库URL，添加Fetch-Pull的URL的解决方法","date":"2019-08-19T03:49:45.000Z","updated":"2023-10-07T08:53:25.030Z","comments":true,"path":"post/58974e7c.html","link":"","permalink":"https://blog.gobyte.cn/post/58974e7c.html","excerpt":"","keywords":null,"text":"缘由由于之前操作，将仓库的fetch地址也就是pull地址，设置成了coding了，但是我需要从GitHub上面pull，所以需要修改。之前设置远程仓库地址都是设置的push，还没有找到设置pull（fetch）地址的方法。所以我直接是修改Git的配置文件config来解决。 解决方法 打开你的仓库目录，打开Windows设置，显示系统隐藏文件，然后就可以看见.git文件夹，而config文件就在这个文件夹内 Git里远程仓库地址是这样的： 1234$ git remote -vorigin git@git.dev.tencent.com:shanl/shanl.git (fetch)origin git@git.dev.tencent.com:shanl/shanl.git (push)origin https://github.com/shanlanCoding/shanlancoding.github.io.git (push) 现在需要把第三个链接origin https://github.com/shanlanCoding/shanlancoding.github.io.git (push) 改成origin https://github.com/shanlanCoding/shanlancoding.github.io.git (fetch) 而第一个链接origin git@git.dev.tencent.com:shanl/shanl.git (fetch)应当删除 git的config文件打开后长这样： 1234567891011121314[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote \"origin\"] fetch = +refs/heads/*:refs/remotes/origin/* url = git@git.dev.tencent.com:shanl/shanl.git url = https://github.com/shanlanCoding/shanlancoding.github.io.git[branch \"HEXO\"] remote = origin merge = refs/heads/HEXO 将[remote &quot;origin&quot;]栏目下的url = https://github.com/shanlanCoding/shanlancoding.github.io.git剪切，然后移动到fetch = +refs/heads/*:refs/remotes/origin/*上一行粘贴，最终如下： 1234567891011121314[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote \"origin\"] url = https://github.com/shanlanCoding/shanlancoding.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* url = git@git.dev.tencent.com:shanl/shanl.git[branch \"HEXO\"] remote = origin merge = refs/heads/HEXO 回到Git命令行查询结果： 1234$ git remote -vorigin https://github.com/shanlanCoding/shanlancoding.github.io.git (fetch)origin https://github.com/shanlanCoding/shanlancoding.github.io.git (push)origin git@git.dev.tencent.com:shanl/shanl.git (push) 此时可以看到GitHub的仓库地址已经变成了fetch了，而腾讯的已经只剩下push了，达到预期效果，成功解决问题！","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.gobyte.cn/tags/Git/"}]},{"title":"Clover资源管理器你在干什么？","slug":"Clover资源管理器你在干什么？","date":"2019-08-18T05:31:55.000Z","updated":"2023-10-07T08:53:25.029Z","comments":true,"path":"post/c7144fb7.html","link":"","permalink":"https://blog.gobyte.cn/post/c7144fb7.html","excerpt":"","keywords":null,"text":"偶然间查看杀毒软件的日志，发现有个木马病毒的记录，原来是Clover程序在后台自动联网下载，不过被杀软拦截了，详情如下图： 通过浏览器打开：down.shusw.com&#x2F;clv&#x2F;upd&#x2F;clv_sp3.5.1.gif后，发现确实是一张很小的图片。但是，你以为事情就是这么简单吗？ 仔细看waterfall的进度条很长，可以简单的理解为网页是由图片、js文件、css文件等组成的。而网页在打开的时候是优先级的顺序来下载的。如果一个文件的waterfall进度条很长，说明这个文件加载的时间也很长。 然后我们仔细看Time这一列，发现总用时4.19S，但是页面中的图片很小，看起来不超过10KB，为什么需要加载4.19S？是对方服务器太慢了吗？直觉判断不是这样，然后仔细看network工具里面的Size列，发现了吗？11.7，单位MB。天哪，什么图片有11.7MB大？果然有问题，根据经验判断，这不是一张普通的图片，更像是图片和文件打包在一起伪装成图片。所以我复制该图片链接，通过浏览器的下载管理下载了下来，下载后的文件属性图如下： 我仔细查询了这个签名，Shanghai Oriental Webcasting Co. Ltd.它是“上海东方网股份有限公司”，看样子是家正规公司，应该不会去破坏普通人的电脑。 重点来了，一张图片没什么内容，但是体积缺异常庞大，这肯定不正常。为了验证我上面的猜测，猜测它是一个伪装的文件。所以我将该文件的后缀名修改为“rar”压缩文件，确实打开成功，如下图： 从目录结构以及文件名来看，它确实是Clover的安装包，目前杀软没有报毒，也没有其他行动。我只能单纯的认为作者是想通过这种方式，去更新它的软件，而不是有其他的图谋在里面。另外还是希望作者少一些流氓，多一些真诚，不要用技术作恶，毕竟电脑软件是否该更新应该让消费者去决定，而不是喧宾夺主成为电脑的主人。 解决方法使用火绒的联网控制功能，对这个EXE程序进行阻止联网即可，如下图：","raw":null,"content":null,"categories":[{"name":"windows","slug":"windows","permalink":"https://blog.gobyte.cn/categories/windows/"}],"tags":[]},{"title":"React入门学习-State和生命周期","slug":"React入门学习-State和生命周期","date":"2019-08-16T09:20:04.000Z","updated":"2023-10-07T08:53:25.033Z","comments":true,"path":"post/cc206ca3.html","link":"","permalink":"https://blog.gobyte.cn/post/cc206ca3.html","excerpt":"","keywords":null,"text":"先讲几个React常识 React一共有两种组件；而组件类似于函数的概念，它最主要的作用是为了代码复用，拼装你需要的功能，你前期可以这么粗略的理解，但是我相信随着你的学习深入，到了后期又会有不一样的理解。另外，React官方强烈建议：不要创建自己的组件【基类】。 在 React 组件中，代码重用的主要方式是组合而不是继承。 两个组件分别为：函数式组件和Class式组件。函数式组件和原生JavaScript的函数是相同的，而Class式组件是ES6新增的，大体的作用是引入了面向对象的概念，这是以前没有的。Class语法请参考MDN 为什么要用Class组件而不是用Function组件呢？使用State、生命周期等新的特性需要用到Class组件。 生命周期什么是生命周期？每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。你可以使用此生命周期图谱作为速查表。在下述列表中，常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。 为什么要使用生命周期？当组件比较多的时候，如果能把不需要使用的组件销毁掉，可以释放非常宝贵的系统资源。说人话就是不要的东西丢垃圾桶里，释放你家里宝贵的可用空间。应用场景例如：当页面有一个定时器，我们这个定时器使用完毕以后应该去销毁，以释放内存，所以这个时候可以用上生命周期方法。 挂载-mount当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下： constructor() static getDerivedStateFromProps() render() componentDidMount() 注意: 下述生命周期方法即将过时，在新代码中应该避免使用它们： UNSAFE_componentWillMount() 卸载-unmount同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。当组件从 DOM 中移除时会调用如下方法： componentWillUnmount() 除了挂载和卸载，还有更新，有兴趣你也可以点击学习。上面的两种方法，都称为“生命周期方法” State什么是State？本次学习后我对State的理解为它是用来保存一些你需要数据的变量，而子组件可以在这个变量里提取你在父组件里传递的数据，类似一个存数据的容器，仅此而已。 正确的使用State关于 setState() 你应该了解三件事： 不要直接修改 State例如，此代码不会重新渲染组件： 12&#x2F;&#x2F; 错误的this.state.comment &#x3D; &quot;你好&quot;; 而是应该使用setState() 12&#x2F;&#x2F; 正确的this.setState(&#123;comment: &quot;你好&quot;&#125;); 另外构造函数constructor是唯一可以给 this.state 赋值的地方： State的更新可能是异步的出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。 因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。 例如，此代码可能会无法更新计数器： 1234&#x2F;&#x2F; 错误this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数： 1234&#x2F;&#x2F; 正确this.setState((state, props) &#x3D;&gt; (&#123; counter: state.counter + props.increment&#125;)); 上面使用了箭头函数，不过使用普通的函数也同样可以： 123456&#x2F;&#x2F; 正确this.setState(function(state, props) &#123; return &#123; counter: state.counter + props.increment &#125;;&#125;); State 的更新会被合并当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。 例如，你的 state 包含几个独立的变量： 1234this.state &#x3D; &#123; title : &#39;React&#39;, content : &#39;React is an wonderful JS library!&#39;&#125; 当只需要修改状态title时，只需要将修改后的title传给setState： 1this.setState(&#123;title: &#39;ReactJs&#39;&#125;); React会合并新的title到原来的组件状态中，同时保留原有的状态content，合并后的State为： 1234&#123; title : &#39;ReactJs&#39;, content : &#39;React is an wonderful JS library!&#39;&#125; 所以 this.setState({title}) 替换了原来的“React”，但是”Content”的内容没有修改。 数据的流动不管是父组件还是子组件都无法知道某个组件是有状态还是无状态的，并且也不关心它是函数式组件还是Class组件。 这就是为什么称State为局部的或者是封装的原因。除了拥有并设置了它的组件，其它组件都无法访问。 组件可以选择把它的State作为props向下传递到它的子组件中： 1&lt;h1&gt; 现在是北京时间： &#123;this.state.date.toLocaleTimeString() &#125; &lt;&#x2F;h2&gt; 也可以用在自定义的组件上： 1&lt;FormattedDate date &#x3D; &#123; this.state.date &#125; &#x2F;&gt; FormattedDate组件会在它的props中接收参数Date，但是组件本身无法知道它是来自于Clock的state，或者Clock的props，又或者是手动输入的： 123function FormattedDate(props) &#123; return &lt;h2&gt;现在是北京时间： &#123;props.date.toLocaleTimeString()&#125;&lt;&#x2F;h2&gt;;&#125; 这种叫做“自上而下”或者“单向”数据流。任何的State总是所属于特定的组件，而且该State派生的任何数据或者UI只能影响“低于”他们的组件。 如果你把一个以组件构成的树，想象成一个props的数据瀑布的话，那么每一个组件的State就像是在任意一个点上给瀑布增加额外的水源，但是它只能向下流动。 为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 Clock 的 App组件： 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock &#x2F;&gt; &lt;Clock &#x2F;&gt; &lt;Clock &#x2F;&gt; &lt;&#x2F;div&gt; );&#125;ReactDOM.render( &lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 每个 Clock 组件都会单独设置它自己的计时器并且更新它。 在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&#x2F;&#x2F; 函数式组件function Clock1(props)&#123; return( &lt;div&gt; &lt;h1&gt;你好，朋友&lt;&#x2F;h1&gt; &lt;h2&gt;现在是&#123; props.date.toLocaleTimeString() &#125;&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; );&#125;&#x2F;&#x2F; Class式组件class Clock2 extends React.Component&#123; &#x2F;&#x2F; 构造函数默认加载并执行一次，起到传递数据的作用 constructor(props)&#123; &#x2F;&#x2F; 获取父类的数据；Class 组件应该始终使用 props 参数来调用父类的构造函数。 super(props); &#x2F;&#x2F; 添加一个data到state内 this.state &#x3D; &#123; date : new Date() &#125;; &#125; &#x2F;&#x2F; 生命周期-挂载-渲染后运行；可以用来加装定时器等作用 componentDidMount()&#123; &#x2F;&#x2F; 添加定时器,接受返回ID this.timerID &#x3D; setInterval( () &#x3D;&gt; this.tick(),1000 ); &#125; &#x2F;&#x2F; 生命周期-卸载- componentWillUnmount()&#123; &#x2F;&#x2F; 清除定时器 clearInterval(this.timerID); &#125; &#x2F;&#x2F; 修改时间 tick()&#123; &#x2F;&#x2F; 修改data数据 this.setState(&#123; date: new Date() &#125;); &#125; &#x2F;&#x2F; 渲染 render()&#123; return( &lt;div&gt; &lt;h2&gt;现在是&#123; this.state.date.toLocaleTimeString() &#125;&lt;&#x2F;h2&gt; &lt;FormattedDate date &#x3D; &#123; this.state.date &#125;&#x2F;&gt; &lt;&#x2F;div&gt; ); &#125;&#125;&#x2F;&#x2F; Class组件-end&#x2F;&#x2F; 多个组件渲染，他们是相互独立的function App()&#123; return ( &lt;div&gt; &lt;Clock2 &#x2F;&gt; &lt;span&gt;---&lt;&#x2F;span&gt; &lt;Clock2 &#x2F;&gt; &lt;span&gt;---&lt;&#x2F;span&gt; &lt;Clock2 &#x2F;&gt; &lt;span&gt;---&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; );&#125;&#x2F;&#x2F; 自定义函数式组件，从父级获取参数function FormattedDate(props) &#123; return &lt;h2&gt;第二种 &#123; props.date.toLocaleTimeString() &#125; &lt;&#x2F;h2&gt;;&#125;&#x2F;&#x2F; 渲染ReactDOM.render( &lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));&#x2F;&#x2F; let node &#x3D; &#123; type : &quot;解构&quot;, name : &quot;解构测试&quot;&#125;;&#x2F;&#x2F; (&#123;type，name&#125;) &#x3D; node;&#x2F;&#x2F;&#123;&#125;在js中作为代码块，单独使用加等号会报错会报错let &#123; type:Type , name:Name &#125; &#x3D; node;let i &#x3D; 0;console.log(Type + i++);console.log(Name + i++); let &#123; type:myType , name:myName &#125; &#x3D; node;console.log(myType + i++);console.log(myName + i++);","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.gobyte.cn/tags/React/"}]},{"title":"待解决的问题","slug":"待解决的问题","date":"2019-08-16T08:31:08.000Z","updated":"2023-10-07T08:53:25.038Z","comments":true,"path":"post/e569aec3.html","link":"","permalink":"https://blog.gobyte.cn/post/e569aec3.html","excerpt":"","keywords":null,"text":"什么是MES系统MESA（Manufacturing Enterprise Solutions Association）对制造执行系统(MES)的定义： 在产品从工单发出到成品完工的过程中，制造执行系统起到传递信息以优化生产活动的作用。在生产过程中，借助实时精确的信息、MES引导、发起、响应，报告生产活动。作出快速的响应以应对变化, 减少无附加价值的生产活动，提高操作及流程的效率。MES提升投资回报、净利润水平、改善现金流和库存周转速度、保证按时出货。MES保证了整个企业内部及供应商间生产活动关键任务信息的双向流动。 页面表单数据的导出 React部署打包npm run build Shell命令动图 123123 治理和管理的区别？ 我学公共管理第二年，渐悟中。区别如下：1、治理指的是个过程，管理是种方法。2、治理目标是协调多方利益，管理更偏向于管理者的利益。3、治理需要多方共同参与，管理主体相对单一。 治理和管理有何区别？ - 倪正文的回答 - 知乎https://www.zhihu.com/question/20096586/answer/16256717","raw":null,"content":null,"categories":[],"tags":[]},{"title":"利用腾讯云低成本优惠券-20元续费域名，最高续费十年","slug":"利用腾讯云低成本优惠券-20元续费域名，最高续费十年","date":"2019-08-15T04:07:02.000Z","updated":"2023-10-07T08:53:25.037Z","comments":true,"path":"post/8d41f951.html","link":"","permalink":"https://blog.gobyte.cn/post/8d41f951.html","excerpt":"","keywords":null,"text":"我已经续满十年，一个身份证号可以领取一次。如果你域名从其他的服务商转入就可以续费两次。我的cn域名续费一次是15元，我是从其他域名商转入，所以我自己的号续费了两次，另外借了八个人的账号。续费操作方法： 领券地址：新用户可以领新用户注册-10券和续费-20券 使用QQ号扫码登陆 领取两种优惠券 云产品 -&gt; 域名与网站 -&gt; 域名管理 -&gt; 选择已有的域名 -&gt; 更多 -&gt; 续费，或者直接点此打开域名管理。如果你域名在万网，或者其他服务商，需要转入，具体如何转入请自行研究，我从22域名网转入只花了不到十分钟的时间。 多撸操作方法 打开领券地址：[新用户可以领新用户注册-10券和续费-20券 发送QQ登陆二维码给你朋友，让对方使用手机QQ，点击图片，识别二维码登陆 让你朋友提供手机号、姓名、身份证号填写资料备用 发送1分钱的支付二维码到你朋友微信上，让他点击图片，识别二维码进行支付 你自己用微信扫码支付优惠后的余款，即可完成续费支付。比如我的CN域名是35-20，所以我支付15元即可。 点此打开域名管理 -&gt; 管理 -&gt;滑动到最底部 -&gt; 域名转移 -&gt; 账户间过户 -&gt; 登陆下一个有优惠券的B账号 -&gt; 账号信息 -&gt; 复制账号ID -&gt; 填入到“过户后账号” 内， 输入验证码完成过户。 登陆到刚刚过户的B账号，重复上面的-续费操作方法 我看了xyz域名首年只要11元 减10只需要1元然后几块钱买个空间学习下淘客也是好的老用户可以领-20券 所有域名都可以续费 立减20每账号只能领一张，可以多撸。多号撸 把域名过户给其他账号 续费完在过户回来 秒过户不需要等需要微信付款1分用于实名认证 单身份证是否可以多撸 最后发发我的战果图，祝大家顺利：","raw":null,"content":null,"categories":[{"name":"骚操作","slug":"骚操作","permalink":"https://blog.gobyte.cn/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}]},{"title":"04-深圳市拓联智能信息技术有限公司面试总结-顺利应届入职以及求职总结","slug":"04-深圳市拓联智能信息技术有限公司面试总结","date":"2019-08-09T10:34:25.000Z","updated":"2023-10-07T08:53:25.028Z","comments":true,"path":"post/8d68fb01.html","link":"","permalink":"https://blog.gobyte.cn/post/8d68fb01.html","excerpt":"","keywords":null,"text":"基本信息 时间：2019年8月1日10点00 地点：深圳市宝安区西乡街道宝源路1053号资信达大厦 公司：深圳市拓联智能信息技术有限公司 职位：物联网研发培训生&#x2F;助理工程师 环境：交通方便，出门步行600米左右就是地铁站，办公环境中等偏上，公司大概只有十几人，说是一家公司其实本质上是一家公司的开发部门，实际上也是这样，之所以重开了一家公司是因为给员工在深圳缴纳社保等需要（我也是后来知道的）。不过我在办公司竟然看到我非常喜欢的电子工具，比如示波器、稳压电源、电烙铁等等工具，这是我最满意也是最让我高兴的地方了。 流程填写个人信息表，这个表还有编号，还注明入档保留三年，看起来流程非常的完善。填写完成之后就给一份简历面试官，一共两位面试官，年纪看着大不了我几岁，直接带我去会议室里开了大屏幕，让我打开浏览器演示我简历上面的项目。其实简历的项目是我的毕业设计，是一个功能简单的在线报名系统，这家公司也是唯一一家让我演示项目并且没有做题的公司。 面试面试官要求演示项目，我从登陆注册页面讲解到用户页面，一直到演示管理员的后台页面以及功能。其中涉及到查询、搜索、删除、修改的功能演示。在演示全匹配查询的时候面试官突然问到有没有做模糊匹配的功能，我记得不太清楚，但是主动的演示了，结果是我没有做模糊匹配，所以我希望能看到我这篇文章的朋友们，尽可能的把自己的项目做完善，这也是能给自己加分的。另外面试官还拓展性的问道了Redis和Docker，我只能回答Redis只是简单的使用了一下，至于Docker我说了下我对这个工具的理解以及我没有使用它的原因。我对Docker理解是它是一个软件的容器，需要运行什么项目可以放在它里面运行，而它其实是一个微型的虚拟机，所以我们可以控制它进行开机、重启、关机等操作。但是我没有使用过它，原因就是我现在还没有使用它的场景，因为我就一两个的项目，完全用不上这款工具。至于以后工作中如果真的要用上，我认为是有信心掌握的。这个面试点说明没事多了解下当下热门的开发工具、环境还是会有意想不到的收获的。后来闲聊中我说了下一开始还以为这家公司是培训班呢，因为也没有打电话，只有一封系统邮件通知我来面试，好在我通过搜索发现是一家正规的公司才敢过来。面试小哥噗的一声就笑了，他告诉我这边是没有HR的，所以简历都是他亲自在看，所以也没有时间打电话通知。我想到这里也就不疑惑了，难怪面试官会直接让我演示项目，由此可见之前的公司可能都没有仔细看或者对我的简历保持着无所谓的态度，也算是伯乐识千里马了吧。说到这里我建议各位简历尽可能完善，尽可能多投递，你只有多投递你才会更大的几率碰到你的伯乐，别无他法。 入职1号面试的技术，2号周五14点总公司的人事专员跟我按流程沟通了下，然后告诉我后面会请示总经理，看看有没有必要跟我聊聊，如果不聊的话直接进入下一个流程。结果周一 一整天人事专员都没有联系我，我到了17点左右发了条短信过去也没有给我回复，最后我在6号周二14点主动给人事打电话联系，同样是无人接听的。好在在16点的时候主动给我回电了，也和总经理按照计划的谈了下工作、人生理想，以及定下了工资。这里我有点意外，招聘公告上面的薪资标准是4-6K，我报价是6.5给他们砍价的空间，我预期最好的情况是给我6K，也有可能给5K，但是5K在深圳确实是很好。没想到总经理给我定下了6K，我一直以为6K就是以后的转正工资了，直到后来收到offer后才发现6K其实是试用期工资，那就说明转正后工资还有可能上浮15%也就是至少可以达到7.5的水平，这是之前没有料到的。 让人不解的是我表达了希望尽快入职的想法以后，总经理却说入职的事情不着急还需要两三天的时间，这到底是什么操作？腹黑一点的想法是不是公司还在挑人？当然也有可能是在走公司的内部流程了。 这一等又是两天，从6号等到了8号，8号16点手机突然拦截了一个固定电话，我不假思索的百度了这个号码发现是总部的。立马回拨过去，接电话的是前台。在我说明来意后给我转接到人事部了，我也没有客套直接自报家门并说了一下事情的经过，对方的人事表示会记录我的问题后我挂断了电话。结果没几分钟人事电话来了，是负责处理我入职的谷小姐打来的电话。简单沟通后确认我的邮箱后给我发送了offer，剩下就是入职体检、准备入职资料了，入职的时间定在了8月12日。 求职总结从7月11号坐车出发，12号到达深圳，截止到今天2019年8月8日一共来深圳27天。这27天里我仅仅只收到了五份面试邀请，还有一份不是软件开发，是一个职校招聘计算机老师，意愿不大所以就推掉了。 四次面试中，第一次是外包公司，办公环境差、薪资待遇低、填了一大堆的个人隐私信息、以及令人体验极差的面试官，这些都是次要的，重要的是面试官都不知道自己的公司需要什么样的员工，所以面试的问题都是一切稀奇古怪的问题，当然也要感谢这些问题，让我在后面的面试中有了经验，面试总结在这里：01-深圳市罗湖区-中科软面试总结 第二次面试是专门从事软件开发的公司，看官网介绍是做汽车语音交互的。所以上来直接做一套算法题，个人认为难度还是比较大的，在该公司除了面试难度较高，其他没有什么不愉快的，特别是最后跟我面试的小哥很和善，年纪看着也不算大，非常耐心的听我讲解解题的思路，以及给我解答题目，非常感谢，面试总结在此：02-深圳市南山区-同行者科技有限公司面试总结 第三家面试体验其实是最好的，我提前了二十多分钟抵达了公司。HR姐姐给我倒了一杯水，这是之前从来没有享受到的待遇。从我主动向HR姐姐索要面试题后才得知，我本次面试没有面试题，也不需要提供简历，面试官也是在远隔千里之外的苏州市，所以会采用视频面试的方法。面试总结在此：03-杜尔涂装系统工程（上海）有限公司ITAC面试总结 第四次也就是本次面试，技术面试很愉快，但是后续的人事沟通以及和总经理的沟通战线拖得太长了，可能是公司还没有决定录取哪个人吧，所以处理拖得久了其他的还能接受。 入职后了解到其实就是总部的办公效率太低，而不是在筛选某个人，筛选人的工作在深圳分部就已经完成了。对了，我入职公司的钉钉群组后发现刚好是第2019个人，而今年恰好是2019年，感觉有种冥冥注定的一样。 —-更新于2019年8月18日01:04:24 求职体会作为一个普通本科应届生来说，找工作其实没有那么的简单。因为从目前的情况来看应届生的技术能力可能不符合公司的要求，甚至还不如培训班的学生。而且加上国内经济不景气，传统的互联网公司生存下去都困难，更别说招新人了。因为大部分的新人入职后需要花费时间进行学习才能跟上同人要求，这学习的时间意味着企业需要花费资金进行培养，这就是大多数的公司不乐意的原因。再加上国内培训班的大量产出，那些刚培训的完的学生简历直接写两年工作经验你敢信？就算不写两年，写个一年的经验，再写上一些看起来高大上又略显真实的项目，你觉得应届生那苍白的简历能过的了HR的筛选吗？ 建议后找工作的朋友，可以多做些项目，不管是临摹的，还是自己设计的小项目，只要自己理解了，能讲出来，那些就是你的。因为知识这种东西只要你自己掌握了它就属于你，不存在你剽窃谁的技术这种歪道理。 在做项目的同时，我建议你买一台阿里云&#x2F;腾讯云的学生机，装上Linux系统，再去挑选注册一个你中意的域名，优先推荐.com域名。这样你每次做完项目以后一定要亲手部署到服务器上，部署的过程中肯定会遇到一些问题，这个时候你不要怕麻烦，你每次解决问题你就会获得多一点的经验，最好把你遇到的问题记录下来，再写上你是如何解决和思考的，坚持下去，最后你简历的项目也有的写了，这样会给你找工作带来不少的加分，自然而然找工作的难度也就会降低的。 如果你不知道做什么项目，我建议你多翻翻GitHub，非常多的优质开源的优质项目等着你学习，你所需要做的就是跟着做起来，仅此而已，总好过你打游戏挥霍青春吧，你说呢？ --- 2019年8月9日22:14:09 记","raw":null,"content":null,"categories":[{"name":"求职","slug":"求职","permalink":"https://blog.gobyte.cn/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.gobyte.cn/tags/Java/"}]},{"title":"03-杜尔涂装系统工程（上海）有限公司ITAC面试总结","slug":"03-杜尔涂装系统工程（上海）有限公司ITAC面试总结","date":"2019-07-19T14:43:22.000Z","updated":"2023-10-07T08:53:25.027Z","comments":true,"path":"post/a316b08b.html","link":"","permalink":"https://blog.gobyte.cn/post/a316b08b.html","excerpt":"","keywords":null,"text":"基本信息时间：2019年7月19日14点00 地点：深圳市宝安区海秀路19号国际西岸商务大厦17A楼10单元；交通方便，出门步行300米左右就是地铁站办公环境不错。 公司：杜尔涂装系统工程（上海）有限公司；但是招聘是ITAC，网上了解了下，ITAC以前是软件公司，我的面试官也告诉我了是被杜尔涂装收购了，所以现在可以说是杜尔的IT部门。 职位：MES-软件工程师 环境：深圳这边的办公室不大，但是员工也不多，我今天看到了有3个实施大姐，还有个应该是经理男性。座位应该有十几个，但是没看见人。另外面试官是在苏州，和我视频面试，介绍说那边还有几个开发，一起加起来开发只有7&#x2F;8人。 流程：没有找我要简历，我问了HR也说不用。我主要拿面试题HR姐姐说没有面试题，还给我倒了杯水，这是之前没有享受到的待遇的，由于是13点30到场，所以等了一会儿HR小姐姐拿了笔记本就让我和苏州的称为“刘哥”的面试官面试。我姑且也称为刘哥吧，刘哥看起来精神干练，有点像我以前学校的数学老师。中年人，最多不过40岁，说话中气足、和善，可以说把第一次面试的“中科软”的“黄利刚”面试官甩到九霄云外了。由于没有做面试题，刘哥直接和我提问面试了。 自我介绍：说的比较乱，简单的说了下自己在哪里上学，籍贯哪里，以后打算在哪里工作，自己的做的项目。 项目介绍：我一共写了两个项目，竭我所能在不吹牛逼的前提下的介绍了一遍。刘哥也提了一些问题，自认为都回答上了。 Java基础： String，StringBuffer，StringBuilder的区别。这个简单，第一次面试以后我就做了以复习，还不会的话你看看这里：01-深圳罗湖中科软面试总结 集合；List和Map都说说；这个我也复习了，简单的说了下ArrayList和LinkedList。以及Map里面的HashMap。这个时候刘哥借势还提问了HashMap和HashTable的区别是什么？我回答HashMap和HashTable几乎没什么区别，唯一有区别是HashTable是线程安全，HashMap是线程不安全。所以HashTable适合多线程使用。单线程则应该使HashMap。若你还不清楚Java集合框架，请点击这里：Java集合框架系统学习 数据结构： 栈和队列；我是大白话说的，栈理解一个瓶子，数据就是豆子。先进入的数据就是豆子进瓶子，所以先出来的豆子是最后放进去的。队列就不同了，可以理解为一个空心的水管，先进入的数据先出去，后进入的数据后出去。 线性和非线性数据结构：这题没答上来，我让刘哥给我讲了讲。刘哥说List之类的数据结构是线性，二叉树之类的数据结构是非线性。 英语怎么样，有四级吗？说到我伤心处了，英语一直没学好所以四级我连考都没有去考，我这人比较诚实，都如实说了。为了挽回一点劣势，我只能和刘哥表决心对学习英语的态度，以及说明已经在坚持学习英语有90多天，大体是我不想错过每一个机会。刘哥也说什么，只是说要英语是因为外资工作的原因，日常会用到一些简单的英语，我依然是表决心以及证明自己经常阅读英文文档和翻译软件。 你有什么想问的吗？ 我耍了个机灵。之前在网上也看到过面经，提到关于“你有什么想问的”环节。这个时候一般要让自己隐性的表现出很想加入这家公司。所以“隐性”很重要，比如说“新人加入后会有什么培训计划吗？”。这个问题既能提现出你的求知欲，还表名了你想加入该公司的想法，可谓是一箭双雕。 后期的项目架构？刘哥答复说以后是用NodeJs做服务器端，调用数据库输出REST Api 输出到前端的Vue，最后交给Vue进行渲染，而且明确表示不会使用Java。 大概多久会有通知？一到两周会通知，好吧，拖这么久，别人工作还要不要继续找了？","raw":null,"content":null,"categories":[{"name":"求职","slug":"求职","permalink":"https://blog.gobyte.cn/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://blog.gobyte.cn/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"02-深圳市南山区-同行者科技有限公司面试总结","slug":"02-深圳市同行者科技有限公司面试总结","date":"2019-07-19T12:27:19.000Z","updated":"2023-10-07T08:53:25.026Z","comments":true,"path":"post/8905a03f.html","link":"","permalink":"https://blog.gobyte.cn/post/8905a03f.html","excerpt":"","keywords":null,"text":"基本信息时间：2019年7月19日10点30 地点：深圳市南山区高新南七道国家高新技术产业创新中心A座1301；这个A座地图上看不见，最后问保安才知道的，出门在外说话多讲礼貌，多问路，能节省很多麻烦。缺点就是离距离地铁站很远1.3公里，步行要十几分钟，这个天气非常热（深圳好像就没有不热的时候） 公司：深圳市同行者科技有限公司 职位：语音开发工程师 环境：环境很不错，所处的是高新技术产业园，所以在这附近的都是科技、电子行业，比如我就看到了创维的牌子。进了大厦还需要登记，否则你没办法过闸机的。登记的时候也没有怎么为难，基本是留个名字和手机号，身份证号和手机号是可选的，这个是在别的公司见不到的情况。 流程：给HR看简历，可能是根据简历给你发试卷和基本信息调查表。注明试卷和答案纸是分开的，不是直接填在试卷上。与第一家公司“中科软科技股份有限公司”不同的是，这家公司没有让我填杂七杂八的信息调查表，这样以后个人信息泄露的风险就降低了，点个赞。 面试题面试题我拍了照，我直接上照片： 在我面试之前已经有两个老哥在做题了，他俩都是面试Java的。一个老哥说自己有点工作经验；另一个老哥说应届，6月底才来深圳，已经面了7&#x2F;8家了，但是还没有拿到offer，做题的时候发现他跟我差不多，写不出几题，同是天涯沦落人，哈哈哈，话不多数直接上真题和正确答案。 1. 不使用语言的分割组合函数（如Java的String.split，php的explode和implode）。1.1字符串按分割串拆分成数组代码思路： 利用String的container方法，判断是否包含分隔符号flag 若包含，则使用indexOf返回分隔符的下标值 使用String.substring来截取字符串。substring一共有有两种用法，这里使用第二中，也就是从0截取到flag str.substring(beginIndex) ;从index向后截取所有字符串，包含beginIndex str.substring(beginIndex, endindex); 向后截取字符串，一直到endIndex。含beginIndex，不含endIndex 把步骤3截取到干净的字符串，添加到数组集合里 截取新的str，由于步骤4已经截取了第一个字符串，所以新的str也需要重新截取。方法是利用步骤3的第一种方法。具体代码是：str.substring(index + flag.length() )。原理是：从flag开始截取，但是不包含flag，所以需要加上flag的长度，也就是flag.length()，最后如此循环即可完成截取。 点击查看完整代码 1234567891011121314151617181920212223242526272829303132 /** * TOO: 分割字符串返回ArrayList * * @author shanLan http://blog.gobyte.cn * @date 2019/7/19 22:02 * @return * 测试字符串 ： String str = \"asf,123,dsaf,dgasd123,asdfa1,asdfs34,dfas23.-\"; */ public static String[] mySplict(String str, String flag) &#123; ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); while (str.contains(flag)) &#123; // 返回标记的下标 int index = str.indexOf(flag); // 把截取好的字符串存起来 String tmp = str.substring(0, index); al.add(tmp); str = str.substring(index + flag.length()); &#125; // 兜底；若字符串里不包含flag，说明这个字符串不需要切割，那么字节添加到ArrayList里 al.add(str); // 通过toArray方法，指定数组类型直接转换。 return al.toArray(new String[al.size()]); &#125;// ------打印结果------/*asf123dsafdgasd123asdfa1asdfs34*/ 1.2实现字符串列表按分割串组合，例如数组：[“ab”,”2”]，通过”&amp;&amp;”分隔符，组成新的字符串“ab&amp;&amp;2”1234567891011121314public static String mySplict2(String[] str, String flag) &#123; /* * 1.先遍历数组，取出每个元素 * 2.判断元素是否为最后一位，若是，则不再加分隔符 * */ StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length; i++) &#123; sb.append(str[i]); if (i &lt; str.length - 1 ) &#123; sb.append(flag); &#125; &#125; return sb.toString();&#125; 2. 找出不大于N的最大质数质数和素数是同一个东西。质数（又称素数），是指在大于1的自然数中，除了1和它本身外，不能被其他自然数整除（除0以外）的数称之为素数（质数）。比1大但不是素数的数称为合数，1和0既非素数也非合数。素数不是奇数。奇数是不能被2整除的数。比如9是奇数，但不是素数。因为9不能被2整除，所以是奇数，但9有1、3、9三个因数，所以不是素数。 在计算机中，计算整除的常用方法一般使用% 运算，读作取模运算，用法：7 % 2 &#x3D; 1 。解释： 7 模以 2 ，商为3，余数为1，这就称之为取模。我目前对取模运算的理解是求余数，更加常见的应用场景： 判别奇偶数 判别素数 求最大公约数 水仙花数 模幂运算 《孙子问题(中国剩余定理)》 凯撒密码 本题是使用取模运算来判别质数，也就是素数。为了便于理解，先列出判别素数的基本思路： 基础版： 定义循环，数字 i &#x3D; n ，还要定义数字 j &#x3D; i - 1，都为自减。且 i 和 j 都要大于 1 （因为质数大于1） 使用取模运算，每个循环 i % j ，并且判断取模结果是否为 0 ，若为 0 则说明该数字不是一个素数，使用break跳出循环，并进行自减，一直到 j &gt;&#x3D; 2 时，若还没有跳出循环，那么此时的 i 肯定是一个质数了。因为质数的定义是不包括被1和自身的整除的数。而 j &gt;&#x3D; 2时，说明 j 到 2之间所有的数字已经遍历完成，这时还没有跳出循环就说明 i 已经符合质数了。 将符合的数字存入到ArrayList中，利用List集合的顺序存入特性，由于是自减循环，所以第一个存入的质数自然为最大的 最后使用ArrayList.get(0)取出第一个下标的数，即为不大于N的最大质数点击查看完整代码 12345678910111213141516171819202122232425262728293031/** * TODO: 求不大于N的最大质数 * * @author shanLan http://blog.gobyte.cn * @date 2019/7/24 0:49 */public static int maxPrimeNum(int n) &#123; // 用来存质数 ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); if (n == 2 || n == 1) &#123; return n; &#125; for (int i = n - 1; i &gt; 1; i--) &#123; // 比i小1的数 for (int j = i - 1; j &gt; 1; j--) &#123; // 非质数 if (i % j == 0) &#123; break;//跳出冫 &#125; // 只有j小于等于2，并且没有break跳出循环时，此时的i才为质数 if (j &lt;= 2) &#123; // 存入集合中，便于后续取出 arr.add(i); &#125; &#125; &#125; // 利用ArrayList顺序存储的特性，将第一个存入的数字取出。 // 原因是我们采用自减遍历，所以第一个遍历出来的质数是最大的 System.err.println(\"不大于\" + n + \"的最大质数=\" + arr.get(0)); return arr.get(0);&#125; 进阶版：利用开平方根，来缩数字的范围，从而提高查找的效率。 原理：因为如果它不是质数，那么它一定可以表示成除了1和它本身之外的两个数相乘，这两个数必然有一个小于等于它的平方根。只要找到小于或等于的那个就行了 1234567891011121314151617public static void main(String[] args) &#123; for (int i = 1000; i &gt; 2; i--) &#123; if (m(i)) &#123; System.err.println(\"N内最大的质数：\" + i); break; &#125; &#125;&#125;public static boolean m(int num)&#123; // 利用JDK的Math的开平方函数，来限定J的范围 for(int j = 2; j&lt;=Math.sqrt(num);j++)&#123; if( num % j == 0 )&#123; return false; &#125; &#125; return true;&#125; 3. 1000个数的范围是[0,999]，有两个相同的数，请设计算法找出来既然不限定语言，我一开始想最简单的方法就是利用Java集合Set的特性来完成，事实上这种方法代码量也是最少。这里再来复习下Set的特性：存取无序；不可重复；没有下标。更详细点击这里 HashSet它的Add()添加元素的时候，会有一个Boolean的返回值。若集合中没有找到存在的元素，则可以存入并且返回True，否则返回False，所以利用该特性直接就能判断哪个元素重复了，下面上示例代码： 123456789101112131415161718192021public static void main(String[] args) &#123; // 构造一个包含1000个数字的空数组 int arr[] = new int[1000]; // 给数组赋值 for (int i = 0; i &lt; 999; i++) &#123; arr[i] = i; &#125; // 添加一个重复的数字 arr[999] = 888; System.err.println(isEquals(arr));&#125;public static int isEquals(int[] i) &#123; HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); for (int j = 0; j &lt; i.length; j++) &#123; // 当添加元素返回True时不进入if if ( !( hashSet.add( i[j] )) ) &#123; return i[j]; &#125; &#125; return -1;&#125; 4. n个人（编号1 ~ n ） 围成一圈从编号1开始报数，从1报到m，报到m的人出来，下一个人继续从1开始报数。编程求最后一个留下的人的编号。 例如： 如人数n&#x3D;3,报数 m&#x3D;4第一次出队：1第二次出队：3最后留下： 2 1. 使用数组和for循环来解题 创建一个数组peopleFags[]，数组长度为总人数，数组的每个元素下标代表每个人，数组的内容表示这个人是否被淘汰。true没有淘汰，false表示已经淘汰 最开始的时候所有人都没有淘汰，所以这个数组应该全部赋值为true 数数是从第一个人开始，所以需要定义一个变量count，初始值为0，代表第一个人 既然是数数，那么肯定要有一个变量记录已经数到了哪个人，所以定义变量index，一开始都是从第一个人开始数数，所以初始值也是0 还需要定义一个变量，记录剩余的人数，peopleResidue，一开始没有人淘汰，所以它等于总人数 所有变量定义完成之后，开始循环处理，循环的条件是总人数不小于1，也就是总人数：total &gt; 1为条件 进入循环后应该判断当前的人peopleFags[index]是不是淘汰了，如没有淘汰，则应该把计数器count++自增一次，随后应该判断count计数器是不是等于报数，因为游戏规则表名等于报数的人要被淘汰，所以当count等于报数时，应该将当前的人赋值为false，既然已经淘汰了，所以要归零。随之还要将剩余人数减1 最后让当前index下标递进一位，并判断index是否等于总人数，如果等于总人数则表示这一轮数完了，所以应该归零重新开始计数 循环结束后遍历peopleFags[]数组，把为true的下标加1，就是最后一个人的编号。 下面是示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void main(String[] args) &#123; int compult = compult(9, 10); if (compult != -1) &#123; System.err.println(\"最后留下来的人是：\" + compult); &#125;&#125;/** * TODO: 计算循环 * * @param total 总人数 * @param keyNumber 报数 * @return int: 最后一个人的编号负 * @author shanLan http://blog.gobyte.cn * @date 2019/7/28 23:33 */private static int compult(int total, int keyNumber) &#123; // 长度为total的布尔型数组，该数组的长度为总人数，下标索引表示哪个人，元素内容True表示未淘汰，False淘汰 boolean[] peopleFlags = new boolean[total]; // 初始化peopleFlags数组，因为一开始所有人都没有淘汰，自然赋值为true for (int i = 0; i &lt; peopleFlags.length; i++) &#123; peopleFlags[i] = true; &#125; // 剩余的人数，一开始没有人被淘汰，所以剩余人数是总人数total int peopleResidue = total; // 计数器；初始值0，每数一个人则加1，当等于总人数total时归零 int count = 0; // 当前数到哪个人，从0开始计数，代表第一个人 int index = 0; // 开始循环，当剩余人数小于等于1，则说明已经是最后一个人，不进入循环 // 否则应该不累加计数器，所以跳过。 while (peopleResidue &gt; 1) &#123; // 进入循环后，判断当前的人的peopleFlags[index]是不是true if (peopleFlags[index]) &#123; // 能进入循环，说明还没有淘汰，所以要累加计数器 count++; // 检查下计数器count，如果等于报数keyNumber，应该归零，因为等于报数的人应该被淘汰出去 if (count == keyNumber) &#123; count = 0; // 既然被淘汰，那么他的peopleFlags[index]应该赋值false peopleFlags[index] = false; // 既然已经淘汰了一个人，那么剩余的总人数应该-1，也就是peopleResidue - 1 peopleResidue--; &#125; &#125; // 当前人index的下标递进一位 index++; //判断当前人index下标是不是等于总人数total，如果等于则说明这一轮循环结束了，所以要归零从0开始继续循环 if (index == total) &#123; index = 0; &#125; &#125; // while循环结束后，剩余的人数是1，被淘汰的已经标记为false，现在要做的是把没有被淘汰的元素peopleFlags[index] = true 的人下标 + 1 // 因为在人类中计数是从1开始，而我们写的程序的计数是从0开始，所以要加1 for (int i = 0; i &lt; total; i++) &#123; if (peopleFlags[i]) &#123; // 返回没有被剔除的人 return i + 1; &#125; &#125; return -1;&#125; 2. 面向对象解题思路本题中有两个对象，一个是人People，还有一个是环Circle。 人： 编号 左边的People 右边的People 环： 总人数 第一个人 最后一个人 添加人() 删除人() 一开始，我们的环是空的，所以我们需要往环里添加人。那么人肯定有编号，所以添加人之前要给人加上编号。 接下来我们要创建一个计数器变量count，初始值为0，它主要是记录我们循环了几次，每循环一次等于数了一个人。当计数器count等于报数keyNumber的时候，说明这个人就需要被淘汰了，具体请看下面环Circle对象的代码： 点击查看-环Circle-代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package pojo;public class circle &#123; private int total = 0; private people fristPeople = null; private people lastPeople = null; /** * TODO: 添加一个人到圈里 * * @param newPeople 新添加的人 * @return void: * @author shanLan http://blog.gobyte.cn * @date 2019/7/31 0:45 */ public void addPeople(people newPeople) &#123; // 当圈里面的总人数为0 if (total &lt;= 0) &#123; // 因为圈里没人时，那么刚添加的这个人的是第一个人，也是最后一个人 fristPeople = newPeople; lastPeople = newPeople; // 同理，所以这个人的左边、右边，都是这个人。 newPeople.setLeftPeople(newPeople); newPeople.setRightPeole(newPeople); &#125; else &#123; // 如果圈里有人，则把该人加到圈的尾部,也就是将之前最后最后一个人的右边设置为新人。例如：现在新人是编号4 // 1 -&gt; 2 -&gt; 3 -&gt; 4 人员顺序示意 lastPeople.setRightPeole(newPeople); // 将新人4的左边设置为之前最后那个人，也就是编号3 newPeople.setLeftPeople(lastPeople); // 将新人的右边，设置为第一个人，也就是编号1 newPeople.setRightPeole(fristPeople); // 把最后一个人设置为新人 lastPeople = newPeople; &#125; total++; &#125; /** * TODO: 删除圈里的人 * * @param p 被删除的人 * @return void: * @author shanLan http://blog.gobyte.cn * @date 2019/7/31 0:58 */ public void deletPeople(people p) &#123; if (total &lt;= 0) &#123; System.err.println(\"圈里总人数小于等于0 ，不能删除！\"); return; &#125; else if (total == 1) &#123; // 当圈里只有一个人，此时应该游戏结束，第一个人和最后一个人都是null fristPeople = lastPeople = null; &#125; else &#123; // 1 -&gt; 2 -&gt; 3 -&gt; 4 人员顺序示意 // 当圈中的人不小于等于0、且大于1则开始正常操作 if (p == fristPeople) &#123; // 如果新人等于第一个人，那么他的右边是则为第一个人。例如删除编号1，删除后编号2将变成第一人 fristPeople = p.getRightPeole(); &#125; else if (p == lastPeople) &#123; // 如果新人是最后一个人，删除后圈里面的最后一个人将变成他左边的人。例如删除4，最后一个人就是4的左边编号为3的人 lastPeople = p.getLeftPeople(); &#125; // 代码走到了这里，说明p既不是第一个人，也不是最后一个人，是处于中间的人 // 例如要删除编号为3的人，那么3删除后，2的右边是4,4的右边为2 // 以编号3为例，获取被删除people编号3左边的人编号2 people leftPeople = p.getLeftPeople(); // 获取被删除people编号3右边的人编号4 people rightPeole = p.getRightPeole(); // 将左边编号2的人的右边的人设置为编号3的人 leftPeople.setRightPeole(rightPeole); // 将编号4的左边的人设置为编号2 rightPeole.setLeftPeople(leftPeople); &#125; total--; &#125; /** * TODO: 计算。调用addPeople()和deletePeople()来完成约瑟夫环 * * @param total 总人数 * @param keyNumber 关键数字，报数 * @return javafx.scene.shape.Circle: * @author shanLan http://blog.gobyte.cn * @date 2019/7/31 1:11 */ public static circle compar2(Integer total, Integer keyNumber) &#123; circle circle = new circle(); for (int i = 0; i &lt; total; i++) &#123; people people = new people(i); // 开始向圈里添加人 circle.addPeople(people); &#125; Integer count = 0; people people = circle.getFristPeople(); while (circle.getTotal() &gt; 1) &#123; // 每数一个人，计数器加1次 count++; // 如果计数器等于keyNumber，说明这个人应该被淘汰 if (count.equals(keyNumber)) &#123; count = 0; circle.deletPeople(people); &#125; // 当people的编号不等于keyNumber的时候，应该当前对象的右边对象赋值给people people = people.getRightPeole(); &#125; return circle; &#125; public circle() &#123; &#125; public circle(int total, people fristPeople, people lastPeople) &#123; this.total = total; this.fristPeople = fristPeople; this.lastPeople = lastPeople; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public people getFristPeople() &#123; return fristPeople; &#125; public void setFristPeople(people fristPeople) &#123; this.fristPeople = fristPeople; &#125; public people getLastPeople() &#123; return lastPeople; &#125; public void setLastPeople(people lastPeople) &#123; this.lastPeople = lastPeople; &#125;&#125; 人People代码： 人People代码完整代码 1234567public class people &#123; private Integer id; private people leftPeople; private people rightPeole; // set / get 省略 &#125;&#125; 主进程Main调用代码： 123456public static void main(String[] args) &#123; int total = 10; //定义要添加的人数 int keyNumber = 3; //数到3退出 circle circle = pojo.circle.compar2(total, keyNumber); System.out.println( total + \"个人围成一圈数数，数到\" + keyNumber + \"的被淘汰，最后剩下的是第\" + circle.getFristPeople().getId() + \"个人。\");&#125; 3. 使用链表来解题使用Java集合自带LinkedList来实现，借用LinkedList的Remove()后， 将任何后续元素移动到左侧（从其索引中减去一个元素）的特性实现。并且判断的条件是index 是否等于集合的最后一个下标，如果是，则说明本轮循环已经到尾部了，需要重新开始循环计数了，具体思路： 创建一个total长度集合，给集合内添加total个数组，从1开始 定义一个下标index，初始值为0 ，它代表需要删除哪个元素 定义一个循环，循环的结束条件是小于keyNumber，也就是循环次数&#x3D; keyNumber - 1 次 利用 index == size() - 1 ，判断是不是已经数到了最后一个元素，如果是，则需要归零index，从0开始计数 当跳出循环时，说明此时index符合删除的条件了 使用remove(index)删除元素，该index元素的后续元素位置都会向左移动，并且索引会-1 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; Integer total = 10; Integer keyNumber = 3; // 创建链表 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; total; i++) &#123; // 给链表里添加编号，从1开始 list.addLast(i + 1); &#125; // 下标 int index = 0; // 当链表的长度大于1时 while (list.size() &gt; 1) &#123; // 循环，限定条件是小于keyNumber，例如keyNumber=3，所以每次循环是3-1次 for (int i = 1; i &lt; keyNumber; i++) &#123; // 如果下标等于列表长度-1 int length = list.size() - 1; // 如果下标等于最大长度-1，说明已经数到了最后一个人了，那么就需要从头开始数，也就是归零。因为最后一个人的下标就是size()-1 if (index == length) &#123; // 下标归零 index = 0; &#125; // 防止越界 else if (index == list.size()) &#123; index = 1; &#125; else &#123; // 下标递进 index++; &#125; &#125; // 删除指定下标；当上面循环结束以后，i &lt; keyNumber跳出循环时，index++的数字正好符合游戏规则， // 因为index是随着 i 在进行自增。例如keyNumber = 3，那么index的数字依次是：2, // 下一轮按理说是5该删除，但是5这步骤不需要累加index了，直接走到了删除的代码，所以第二轮是删除了下标index= 4的元素 // 同上，应该累加到7的时候删除元素，但是此时代码跳到了删除元素那样，所以index没有累加，此时index是7 list.remove(index); &#125; System.out.println(total + \"个人围成一圈数数，数到\" + keyNumber + \"的被淘汰，最后剩下的是第\" + list.get(0) + \"个人。\");&#125; 参考自：约瑟夫环的几种实现方式 - 菜鸟小站 - OSCHINA - https://my.oschina.net/jack90john/blog/1791110 5. 26个字母a-z，找出所有字母的组合，a,b,c,ab,abc,a~z都是一个组合（顺序无关）待补充","raw":null,"content":null,"categories":[{"name":"求职","slug":"求职","permalink":"https://blog.gobyte.cn/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://blog.gobyte.cn/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"01-深圳市罗湖区-中科软面试总结","slug":"01-深圳罗湖中科软面试总结","date":"2019-07-18T14:37:55.000Z","updated":"2023-10-07T08:53:25.026Z","comments":true,"path":"post/4a74da6f.html","link":"","permalink":"https://blog.gobyte.cn/post/4a74da6f.html","excerpt":"","keywords":null,"text":"基本信息时间：2019年7月17日14点30 地点：深圳市，罗湖区，爵士大厦23层，17-18室 公司：中科软科技股份有限公司 职位：Java开发工程师 面试官：黄利刚 办公环境：办公环境很一般，估计不到30㎡坐满了人，每个人一个格子桌连在一起，脑补下大学机房的环境，可能更紧凑。 面试流程：给HR看简历，可能是根据简历给你发试卷和基本信息调查表。特别注明试卷和调查表、答案纸是分开的，不是直接填在试卷上。写完答案以后HR就叫了面试官进行面试，这里说下这位面试官。虽然看起来他技术很厉害（谢顶），但是说话有气无力，声音非常小而且普通话也不标准。声音小到我每个问题都听不见不得不提醒他，体验非常的差。 试卷这里夸一下这家公司，试卷比较正常，都是基础的题目，一共分为三大类： 选择题，考察基本语法和人脑运行Java代码 简答题，考察框架知识，以及基本的常用的Api SQL题，给两张表，然后根据表的内容来手写SQL 考题回忆1.选择题记不住，印象最深的就是让你人脑运行Java，考你Java的作用域，所以不写总结2. String和StringBuffer以及StringBuilder，哪个效率高？为什么？我之前仅知道StringBuffer快，但是为什么快我不知道，更没有通过StringBuilder。下面贴出网上的答案： 在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 小结： （1）如果要操作少量的数据用 String； （2）多线程操作字符串缓冲区下操作大量数据 StringBuffer； （3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 3.反射是什么？如何用反射？反射实例化类的3个常用方法？我仅了解反射的原理，实际方法也只是学习的时候临摹了几次，所以不记得如何使用反射，下面贴出完整答案： 高端点说：动态加载一个类对象，然后得到这个类对象的公私有方法、字段。那么问题是怎么加载这个类对象？所以就要用到反射的实例方法，一共有三种： 1234567// 1. 通过Object的getClass()加载一个实例对象Studnet stu = new Student();Class cls = stu.getClass();// 2. 通过类名Class stu = Student.class;// 3. 通过类的具体路径，加载Class&lt;?&gt; clz = Class.forName(\"fs.Student\"); 总结： 第一种对象都有了，还要反射干嘛？ 需要导包，否则编译错误。 一般是通过forName，参数是一个类的路径，可以写在配置文件里。 资料：Java基础之—反射（非常重要） 拓展知识：4.反射怎么获取公私有方法、字段？获取方法以及调用思路如下： 获得Class对象，通过上述的三种方法即可，推荐使用：Class.forName(&quot;xxx.student&quot;) 通过Class对象，生成并强转成对象实例：(Student) aClass.newInstance(); 通过Class对象，来获取方法数组：aClass.getMethods() 通过方法数组遍历出所有的方法，一般使用forEach遍历 被操作的对象 Student.class 点击查看完整Student代码 123456789101112131415161718192021222324252627282930313233343536373839package reflect;public class Student &#123; String name; int age; Boolean mySex; // false 女；true 男 private Student(String name, int age, Boolean mySex) &#123; this.name = name; this.age = age; this.mySex = mySex; &#125; public void say(String str) &#123; if (str.equals(\"\")) System.err.println(\"你什么都没说.\"); System.out.println(str); &#125; private void mySay() &#123; System.out.println(\"这是私有方法\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", mySex=\" + mySex + '&#125;'; &#125;&#125; 4.1 通过getMethods() 遍历所有公开方法123456789101112131415161718192021222324252627// 取得ClassClass&lt;?&gt; aClass = Class.forName(\"reflect.Student\");// 通过Class生成对象Student stu = (Student) aClass.newInstance();// 通过Class取到公开方法数组Method[] methods = aClass.getMethods();// 遍历方法数组，得到所有的方法名for (Method m : methods) &#123; System.err.println(\"公有方法：\" + m.getName());&#125;// 打印结果/*公有方法：toString公有方法：getName公有方法：setName公有方法：getAge公有方法：say公有方法：setAge公有方法：wait公有方法：wait公有方法：wait公有方法：equals公有方法：hashCode公有方法：getClass公有方法：notify公有方法：notifyAll*/ 4.2 通过getDeclaredMethods() 遍历所有公开&#x2F;私有方法123456789101112131415161718// 取得ClassClass&lt;?&gt; aClass = Class.forName(\"reflect.Student\");// 包含了私有和公有方法Method[] declaredMethods = aClass.getDeclaredMethods();// forEach遍历for (Method dm : declaredMethods) &#123; System.err.println(\"私有方法：\" + dm.getName());&#125;// 打印结果/*私有方法：toString私有方法：getName私有方法：setName私有方法：mySay私有方法：getAge私有方法：say私有方法：setAge*/ 4.3调用指定共有方法 得到class对象，通常使用Class.forName() 通过class对象的newInstance() 得到一个实例，并把这个实例强转成你需要的对象 通过class对象的getMethod()，拿到你要调用的方法；第一个参数是需要调用的方法名，第二个是该方法的参数类型的Class。如果方法没有参数，则应该填写null，比如getName()就没有参数 通过指定方法的invoke()，第一个参数传入该方法的对象，第二个参数是该方法的参数，如果没有则不填写 1234567891011121314151617181920212223242526@Testpublic void function1() &#123; try &#123; // 得到class Class&lt;?&gt; aClass = Class.forName(\"reflect.Student\"); // 创建实例，并强转成学生对象 Student student = (Student) aClass.newInstance(); student.setName(\"赵云\"); // 得到指定的方法 Method say = aClass.getMethod(\"say\", String.class); // 第一个参数：方法名；第二个参数：方法的参数类型。这里的getName()它不需要参数，所以为null Method name = aClass.getMethod(\"getName\", null); // 传入方法的对象，以及要打印的字符串，并调用方法 say.invoke(student, \"你好，测试invoke方法\"); System.err.println(\"名字：\" + name.invoke(student)); &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125;// 打印结果/*你好，测试invoke方法名字：赵云*/ 4.4 调用私有方法因为是私有方法，和调用公开方法的区别是需要使用method.setAccessible(true)，否则无法调用。 1234567891011121314151617181920212223242526@Testpublic void function2() &#123; try &#123; // 得到class Class&lt;?&gt; aClass = Class.forName(\"reflect.Student\"); // 创建实例，并强转成学生对象 Student student = (Student) aClass.newInstance(); student.setName(\"赵云\"); // 得到指定的方法 Method mySay = aClass.getDeclaredMethod(\"mySay\",null); // 修改权限，否则不能调用私有方法并报错：IllegalAccessException mySay.setAccessible(true); // 传入方法的对象，以及要打印的字符串，并调用方法 mySay.invoke(student); &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125;/* 打印输出这是私有方法* */ 4.5 调用私有字段Field 通过aClass.getDeclaredField(&quot;mySex&quot;);拿到私有字段 给字段设置权限，允许访问mySex.setAccessible(true); 给私有字段赋值：mySex.setAccessible(true); 1234567891011121314151617181920212223242526@Testpublic void function3() &#123; try &#123; // 得到class Class&lt;?&gt; aClass = Class.forName(\"reflect.Student\"); // 创建实例，并强转成学生对象 Student student = (Student) aClass.newInstance(); // 获取私有的字段 Field mySex = aClass.getDeclaredField(\"mySex\"); // 设置权限，允许访问私有字段 mySex.setAccessible(true); // 私有字段赋值 mySex.set(student, false); System.err.println(student.toString()); &#125; catch (InstantiationException | ClassNotFoundException | NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125;/* 打印结果 Student&#123;name='null', age=0, mySex=false&#125; */ 4.6 调用私有构造函数Constructor 拿到class 通过aClass.getDeclaredConstructor(String.class, int.class, Boolean.class);拿到私有构造函数 使用setAccessible()设置权限 使用步骤2创建好的私有构造函数，用newInstance(&quot;兰陵王&quot;, 30, true)创建实例并强转类型 打印测试结果 123456789101112131415161718192021@Testpublic void function4() &#123; &#x2F;&#x2F; 得到class Class&lt;?&gt; aClass &#x3D; null; try &#123; aClass &#x3D; Class.forName(&quot;reflect.Student&quot;); &#x2F;&#x2F; 创建私有构造函数，并指定参数的类型 Constructor&lt;?&gt; declaredConstructor &#x3D; aClass.getDeclaredConstructor(String.class, int.class, Boolean.class); &#x2F;&#x2F; 设置权限，允许反射 declaredConstructor.setAccessible(true); &#x2F;&#x2F; 创建实例，并强转成Student对象 Student 兰陵王 &#x3D; (Student) declaredConstructor.newInstance(&quot;兰陵王&quot;, 30, true); System.err.println(兰陵王.toString()); &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125;&#x2F;*打印结果：Student&#123;name&#x3D;&#39;兰陵王&#39;, age&#x3D;30, mySex&#x3D;true&#125; *&#x2F; 参考资料：Java高级特性——反射 - 简书 反射面试题 - 请了解下 - 简书 总结如果比较空的话，可以去做做题，体验下面试氛围，获得一点面试的经验。事实上我也确实拿到了一点面试经验，并且在后面的面试中派上用场了。用我表弟的话说：“面向经验面试”。—–2019年7月19日20:34:51","raw":null,"content":null,"categories":[{"name":"求职","slug":"求职","permalink":"https://blog.gobyte.cn/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://blog.gobyte.cn/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"MIUI真的负优化吗？","slug":"MIUI真的负优化吗？","date":"2019-07-16T05:25:27.000Z","updated":"2023-10-07T08:53:25.032Z","comments":true,"path":"post/738b9ed9.html","link":"","permalink":"https://blog.gobyte.cn/post/738b9ed9.html","excerpt":"","keywords":null,"text":"背景我是2017年09月买的陶瓷版米6，一直用的挺好的，平常看看头条，打打农药，也不烫，最多就温热。但是这种情况只维持到了上周。手机明显感觉烫的厉害，看了下电池有45℃。这就清楚了，人体才37℃，电池比体温还高那么多。 我的猜测 一般来说电池使用时间久了，电池内部电阻增大，温度升高也是正常。但是我这块电池在6月20号前往官方售后花了99元更换的，所以电池内阻大导致发烫的理由说不过去。 运行复杂的程序；实际上我仅仅使用今日头条此类的轻应用，就能达到高温，快速掉电的情况。 另外我最近没有安装新的软件，室温也不高23°，空调恒温，所以软件和室温也说不过去。 手机倒是更新了系统，一直更新最新的开发版，难道新系统导致的？会不会新系统不稳定，或者类似苹果的恶意代码负优化？？？并不排除这个可能性，毕竟Apple这种级别公司都能做出来。再结合今年的小米公司的销售情况，OV公司都来抢占小米的用户，足以说明今年手机市场行情很一般，如果这个时候MIUI再来个负优化也不是不可能的。 网友的情况起初我只是单纯的认为新版本不稳定，或者有负优化代码。当时在我刚才看到了论坛的另一位用户的帖子，我才知道可能所有的版本有负优化代码，帖子原文链接：米6那个版本好用_小米6_MIUI论坛 根据各个网友的回复，类似这种突然开始卡顿，发热，掉电快的情况不是一个人。对于MIUI是否有远程“负优化”功能，保持怀疑的态度，因为没法查看源代码。 我的想法本来还打算降级的，结果看到上面网友的情况，我也放弃了想法。但是作为手机公司，想要挣钱、获利，是无可厚非的事情，我也可以理解。但是你不应该通过负优化系统，来迫使用户更换新的手机。你今天让用户体验下降，你能保证用户下次换手机还选择你们的品牌？多行不义必自毙，还望珍重。对我来说，如果大不了再刷入一个第三方的系统，仅此而已。 求助如果有懂的老哥，还请提供下方法对安卓系统的资源监控以及记录。比如记录CPU的占用率日志、rom日志、IO日志，记录进程的电池消耗等情况。这样的话就能知道到底是哪个进程在消耗我的手机，从而就不用停留在猜想的层面，直接找到拖慢手机速度的元凶。","raw":null,"content":null,"categories":[{"name":"手机","slug":"手机","permalink":"https://blog.gobyte.cn/categories/%E6%89%8B%E6%9C%BA/"}],"tags":[{"name":"小米6","slug":"小米6","permalink":"https://blog.gobyte.cn/tags/%E5%B0%8F%E7%B1%B36/"}]},{"title":"2019-2020届-Java应届生面试题总结，附带真实面试记录","slug":"Java练习题","date":"2019-07-13T12:21:02.000Z","updated":"2023-10-07T08:53:25.031Z","comments":true,"path":"post/6669b4ec.html","link":"","permalink":"https://blog.gobyte.cn/post/6669b4ec.html","excerpt":"","keywords":null,"text":"1. map怎么实现hashcode和equals,为什么重写equals必须重写hashcode1. equals方法是Object类的一个基本方法，他实际上是用来比较两个对象的引用地址是否一致，从而返回一个Boolean结果。123public boolean equals(Object obj) &#123; return (this == obj); &#125; 2. equals()与‘&#x3D;&#x3D;’的区别 大多人会说`equlas`是比较内容，而`==`是比较内存地址。但是从上面的代码可以得知，`equals`实际上是借用了`==`运算符，比较了内存地址，所以上述的回答是正确的吗？先看一段示例代码： 12345678910111213public class Car &#123; private int batch; public Car(int batch) &#123; this.batch = batch; &#125; // ---------------------------- public static void main(String[] args) &#123; Car c1 = new Car(1); Car c2 = new Car(1); System.out.println(c1.equals(c2)); System.out.println(c1 == c2); &#125;&#125; 返回结果： 12falsefalse 分析：对于==返回的flase很好理解，，因为==是比较内存地址，而两个Car对象的地址是不同的，所以自然是false。但是对于equals返回的false，是怎么理解的？如果说equals是比较内容，此时应该是返回true，为什么是返回false？这是因为Java里所有的对象都是基于Object类，所以Car类也是继承自Object类，自然也有equals方法。但是从问题1的代码可以得知，equals方法的是依赖于运算符==，所以在不重写equals方法的时候，默认还是比较两个对象的内存地址，两个对象的地址不同，自然返回false。如果我想让Car的batch相等，则用equals也返回true时，应该怎么做？在Car里，重写equals方法，判断Car的batch属性即可，示例代码如下： 12345678@Overridepublic boolean equals(Object obj) &#123; if (obj instanceof Car) &#123; Car c = (Car) obj; return batch == c.batch; &#125; return false;&#125; 代码原理：通过instance关键字，判断对象是否属于Car类，通过后进一步判断batch属性是否相等。否则返回false。 总结：默认情况下equals方法和&#x3D;&#x3D;是等价的，是对比对象的内存地址。但是我们可以通过方法重写，按照我们自己的需求进行比较。例如String类的equals方法，是比较字符串的序列，而不再是内存地址。 3.为什么重写equals()的同时还得重写hashCode()Map集合在添加元素的时候，先要计算该元素的Hash值，然后根据Hash值才决定该元素的存储位置。当多个元素的Hash值相同的时候，就会以链表的形式存储。但是在存储之前还需要与旧元素进行对比是否相同，如果相同则不存入。不重写HashCode会导致相同内容的一个对象，在取出时为null。原因就是虽然两个对象内容相同，但是由于没有重写HashCode方法，导致默认调用Object类的HashCode方法，返回了该对象的地址，而两个对象虽然内容是相同，但是地址不同的，那么新的对象就去一个不存在bucket里寻找，自然是返回null。 参考自：重写equal()时为什么也得重写hashCode()之深度解读equal方法与hashCode方法渊源 多线程的start和run函数的区别 2.新人的疑惑：什么是Java的三大特性，五大原则什么是面向对象？ 面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。 下面用一张图诠释什么是面向对象： 三大特性： 封装 encapsulation 把现实中存在的事物，封装成抽象成类。类可以把属性field、方法function只让可信的类或者对象来操作，对不可信的进行隐藏。一个类就是封装encapsulation了一些数据这操作这些数据的代码的逻辑实体。在一个对象的内部，某些代码，或者某系数据是可以被私有的，也就是不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 个人理解：Java封装是先把现实生活中某个事物，比如汽车给抽象成一个Java类也就是Class文件。既然汽车有车轮、方向盘、能开起来，那么抽象后的Java类应该用属性（字段Field）、方法function来描述这个事物。例车有四个轮子，有一个方向盘，这些都可以抽象成字段。那么方法是什么？可以把汽车运行抽象成一个Run()方法。既然是封装，那么肯定还要提到权限等级，因为我这些车轮、方向盘的属性，以及汽车Run()的调用，不是任何一个人，某个对象就能调用的。只有取得了驾照的人才能开车，只有具有修理资质的人才能为我修车，所以我就需要使用上权限修饰符，如下表格所示。这些种种的规则，其实都是为了将显示中的物体描述成代码，让程序员更好的写出逻辑代码，毕竟即使面向再通俗易懂，最终还是需要翻译成二进制共给CPU进行处理，所以面向对象也好，面向过程也好它其实是为了服务于程序员，仅此而已。所以如果你真的够厉害，你的键盘只需要0&#x2F;1两个键来编程也不是不可以。 访问权限 类 包 子类 其他包 public √ √ √ √ protect √ √ √ × default √ √ × × private √ × × × 具体详细信息请参见：java中4种修饰符访问权限的区别及详解全过程 继承 extends 继承是让某个类型的对象获得另一个类型对象的属性、方法。支持按级分类的概念。继承是指这样的一种能力：他可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行拓展。通过继承创建的新类称之为“子类”或者“派生类”，被继承的类称之为“父类”、“基类”、“超类”。继承的使用方式一共有两种：实现继承、接口继承。实现继承就是继承父类的属性、方法，不需要额外的代码进行编写就能直接使用。接口继承是指仅使用属性、方法的名称，但是子类必须要实现方法。 个人理解：实现继承就是拥有父类的所有的属性、方法，拿来直接用，不再需要进行额外的编码。例如儿子继承了父亲的财产，父亲的财产儿子拿来就可以使用，不需要为了这些财产去做一些劳动。接口继承，接口继承更新是定一个规矩，让子类把这个规矩完善并实现出来。例如家有家法，族有族规，但是族规只说不能伤天害理，但是没有规定哪些事情是伤天害理的。所以子孙们需要继承族规并实现出来，例如根据当今社会对族规进行完善，不能让族违反国家法律。简单说接口继承制告诉你现在有哪些属性，有哪些方法。而这些属性类型，方法的参数类型、个数，以及返回类型都是固定的。至于你方法体内的代码怎么做我不管你，你只需要按照我的这个格式返回结果就行。 多态 多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。 对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。 Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。 多态存在的三个必要条件 要有继承：在多态中必须存在有继承关系的子类和父类。 要有重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 父类引用指向子类对象：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。 参考：Java多态性：Java什么是多态？ 五大原则：1. 单一职责原则SRP(Single Responsibility Principle)指一个类要功能单一，不要包罗万象。如同一个人，分配的工作不能太多，否则一天到晚虽然忙忙碌碌，但是效率却高不起来。 职员类例子： 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要ifelse判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！ 2.开放封闭原则OCP(Open－Close Principle)一个模块在拓展性方面应该是公开的，而在可更改性方面应该是封闭的。比如：一个网络模块，原来是服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端代码的前提下，能够增加客户端功能的实现代码，这就要求在设计之初，就应当将客户端和服务端的功能分开，把公共部分的抽象出来。 变化来临时，如果不必改动软件实体裁的源代码，就能扩充它的行为，那么这个软件实体设计就是满足开放封闭原则的。如果说我们预测到某种变化，或者某种变化发生了，我们应当创建抽象类来隔离以后发生的同类变化。 3.里氏替换原则(the Liskov Substitution Principle LSP)子类应当能够替换父类，并且出现在父类能够出现的任何地方。比如公司举办年度晚会，所有员工都可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应该可以参加抽奖，否则这家公司内部就会不和谐。 在这个原则中父类应尽可能使用接口或者抽象类来实现！ 子类通过实现了父类接口，能够替父类的使用地方！ 通过这个原则，我们客户端在使用父类接口的时候，通过子类实现！ 意思就是说我们依赖父类接口，在客户端声明一个父类接口，通过其子类来实现 这个时候就要求子类必须能够替换父类所出现的任何地方，这样做的好处就是，在根据新要求扩展父类接口的新子类的时候而不影响当前客户端的使用！ 4.依赖倒置原则(the Dependency Inversion Principle DIP)传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！ 假设B模块比A模块级别低，但是B需要使用A的功能，这个时候B不应当使用A中的具体类；而是应当有B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口，这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B的定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也依赖于A的实现，那么就可能造成了循环依赖。一个常见的问题就是编译A模块是需要包含B模块的class文件，而编译B时需要包含A模块的class文件。 建议必读：轻松学，浅析依赖倒置（DIP）、控制反转(IOC)和依赖注入(DI) 5.接口分离原则(the Interface Segregation Principle ISP)使用多个专门的接口比使用单个接口要好的多！模块间要通过抽象接口来隔离开，而不是通过具体的类强耦合起来。 在我实际编程中，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！ 3.string,string buffer,string builder它们各自的区别，为什么要使用？请见：String和StringBuffer以及StringBuilder，哪个效率高？为什么？4.Java多线程的start和run方法的区别？ Start()：它是用来启动一个新的线程。通过start()启动的线程，出于就绪（可运行）的状态，但是并没有运行，一旦得到了CPU的时间片，就开始执行相应线程的run()方法，这里方法run()称之为线程体，它包含了这个要执行的线程的内容。run()执行结束，此线程随机终止。start()不能被重复的调用。用start()来启动线程，真正实现了多线程运行，即无需等待某个run()方法执行完毕就执行下面的代码，即进行了线程的切换。 run()：和普通成员方法一样，可以被重复的调用。如果直接调用run()方法并不会启动新的线程！！！程序中依然只有主线程这一个线程，其程序执行路径还是只有这一条，还是要顺序执行，还是要等待run()方法体执行完毕才可执行下面代码，这样并没有达到多线程的目的。 示例代码： 12345678910111213141516171819202122232425262728293031323334/** * TODO: 多线程测试start和run方法 * * @author shanLan http://blog.gobyte.cn * @date 2019/8/5 23:21 */public class threadTest &#123; public static void main(String[] args) &#123; Runner1 r = new Runner1(); //这是方法调用，而不是开启一个线程 r.run(); //调用了Thread(Runnable target)方法。且父类对象变量指向子类对象。 Thread t = new Thread(r); t.start(); // 在主线程里进行循环执行 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"进入Main Thread运行状态\" + i); &#125; &#125;&#125;/** * TODO: 实现了这个接口，jdk就知道这个类是一个线程 * * @author shanLan http://blog.gobyte.cn * @date 2019/8/5 23:29 */class Runner1 implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"进入Runner1运行状态\" + i); &#125; &#125;&#125; 打印结果： 点击查看完整打印结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300进入Runner1运行状态0进入Runner1运行状态1进入Runner1运行状态2进入Runner1运行状态3进入Runner1运行状态4进入Runner1运行状态5进入Runner1运行状态6进入Runner1运行状态7进入Runner1运行状态8进入Runner1运行状态9进入Runner1运行状态10进入Runner1运行状态11进入Runner1运行状态12进入Runner1运行状态13进入Runner1运行状态14进入Runner1运行状态15进入Runner1运行状态16进入Runner1运行状态17进入Runner1运行状态18进入Runner1运行状态19进入Runner1运行状态20进入Runner1运行状态21进入Runner1运行状态22进入Runner1运行状态23进入Runner1运行状态24进入Runner1运行状态25进入Runner1运行状态26进入Runner1运行状态27进入Runner1运行状态28进入Runner1运行状态29进入Runner1运行状态30进入Runner1运行状态31进入Runner1运行状态32进入Runner1运行状态33进入Runner1运行状态34进入Runner1运行状态35进入Runner1运行状态36进入Runner1运行状态37进入Runner1运行状态38进入Runner1运行状态39进入Runner1运行状态40进入Runner1运行状态41进入Runner1运行状态42进入Runner1运行状态43进入Runner1运行状态44进入Runner1运行状态45进入Runner1运行状态46进入Runner1运行状态47进入Runner1运行状态48进入Runner1运行状态49进入Runner1运行状态50进入Runner1运行状态51进入Runner1运行状态52进入Runner1运行状态53进入Runner1运行状态54进入Runner1运行状态55进入Runner1运行状态56进入Runner1运行状态57进入Runner1运行状态58进入Runner1运行状态59进入Runner1运行状态60进入Runner1运行状态61进入Runner1运行状态62进入Runner1运行状态63进入Runner1运行状态64进入Runner1运行状态65进入Runner1运行状态66进入Runner1运行状态67进入Runner1运行状态68进入Runner1运行状态69进入Runner1运行状态70进入Runner1运行状态71进入Runner1运行状态72进入Runner1运行状态73进入Runner1运行状态74进入Runner1运行状态75进入Runner1运行状态76进入Runner1运行状态77进入Runner1运行状态78进入Runner1运行状态79进入Runner1运行状态80进入Runner1运行状态81进入Runner1运行状态82进入Runner1运行状态83进入Runner1运行状态84进入Runner1运行状态85进入Runner1运行状态86进入Runner1运行状态87进入Runner1运行状态88进入Runner1运行状态89进入Runner1运行状态90进入Runner1运行状态91进入Runner1运行状态92进入Runner1运行状态93进入Runner1运行状态94进入Runner1运行状态95进入Runner1运行状态96进入Runner1运行状态97进入Runner1运行状态98进入Runner1运行状态99进入Main Thread运行状态0进入Main Thread运行状态1进入Main Thread运行状态2进入Main Thread运行状态3进入Main Thread运行状态4进入Main Thread运行状态5进入Main Thread运行状态6进入Main Thread运行状态7进入Main Thread运行状态8进入Main Thread运行状态9进入Runner1运行状态0进入Runner1运行状态1进入Main Thread运行状态10进入Runner1运行状态2进入Runner1运行状态3进入Runner1运行状态4进入Runner1运行状态5进入Runner1运行状态6进入Runner1运行状态7进入Main Thread运行状态11进入Main Thread运行状态12进入Runner1运行状态8进入Main Thread运行状态13进入Runner1运行状态9进入Main Thread运行状态14进入Runner1运行状态10进入Main Thread运行状态15进入Runner1运行状态11进入Main Thread运行状态16进入Runner1运行状态12进入Main Thread运行状态17进入Runner1运行状态13进入Main Thread运行状态18进入Runner1运行状态14进入Runner1运行状态15进入Runner1运行状态16进入Runner1运行状态17进入Runner1运行状态18进入Runner1运行状态19进入Runner1运行状态20进入Runner1运行状态21进入Runner1运行状态22进入Main Thread运行状态19进入Runner1运行状态23进入Main Thread运行状态20进入Runner1运行状态24进入Main Thread运行状态21进入Runner1运行状态25进入Main Thread运行状态22进入Runner1运行状态26进入Main Thread运行状态23进入Runner1运行状态27进入Main Thread运行状态24进入Runner1运行状态28进入Main Thread运行状态25进入Runner1运行状态29进入Main Thread运行状态26进入Runner1运行状态30进入Main Thread运行状态27进入Runner1运行状态31进入Main Thread运行状态28进入Runner1运行状态32进入Main Thread运行状态29进入Runner1运行状态33进入Main Thread运行状态30进入Runner1运行状态34进入Main Thread运行状态31进入Runner1运行状态35进入Main Thread运行状态32进入Runner1运行状态36进入Main Thread运行状态33进入Runner1运行状态37进入Main Thread运行状态34进入Runner1运行状态38进入Main Thread运行状态35进入Runner1运行状态39进入Main Thread运行状态36进入Runner1运行状态40进入Main Thread运行状态37进入Runner1运行状态41进入Main Thread运行状态38进入Runner1运行状态42进入Main Thread运行状态39进入Runner1运行状态43进入Main Thread运行状态40进入Main Thread运行状态41进入Main Thread运行状态42进入Main Thread运行状态43进入Main Thread运行状态44进入Main Thread运行状态45进入Main Thread运行状态46进入Main Thread运行状态47进入Main Thread运行状态48进入Main Thread运行状态49进入Main Thread运行状态50进入Main Thread运行状态51进入Main Thread运行状态52进入Runner1运行状态44进入Main Thread运行状态53进入Main Thread运行状态54进入Main Thread运行状态55进入Main Thread运行状态56进入Main Thread运行状态57进入Main Thread运行状态58进入Main Thread运行状态59进入Main Thread运行状态60进入Runner1运行状态45进入Main Thread运行状态61进入Main Thread运行状态62进入Main Thread运行状态63进入Main Thread运行状态64进入Main Thread运行状态65进入Main Thread运行状态66进入Main Thread运行状态67进入Main Thread运行状态68进入Runner1运行状态46进入Main Thread运行状态69进入Main Thread运行状态70进入Main Thread运行状态71进入Main Thread运行状态72进入Main Thread运行状态73进入Main Thread运行状态74进入Main Thread运行状态75进入Main Thread运行状态76进入Runner1运行状态47进入Main Thread运行状态77进入Main Thread运行状态78进入Main Thread运行状态79进入Runner1运行状态48进入Runner1运行状态49进入Runner1运行状态50进入Runner1运行状态51进入Runner1运行状态52进入Runner1运行状态53进入Runner1运行状态54进入Runner1运行状态55进入Runner1运行状态56进入Runner1运行状态57进入Runner1运行状态58进入Runner1运行状态59进入Runner1运行状态60进入Main Thread运行状态80进入Main Thread运行状态81进入Runner1运行状态61进入Runner1运行状态62进入Runner1运行状态63进入Runner1运行状态64进入Runner1运行状态65进入Main Thread运行状态82进入Runner1运行状态66进入Main Thread运行状态83进入Runner1运行状态67进入Runner1运行状态68进入Runner1运行状态69进入Runner1运行状态70进入Runner1运行状态71进入Runner1运行状态72进入Runner1运行状态73进入Runner1运行状态74进入Runner1运行状态75进入Main Thread运行状态84进入Main Thread运行状态85进入Main Thread运行状态86进入Main Thread运行状态87进入Main Thread运行状态88进入Main Thread运行状态89进入Main Thread运行状态90进入Main Thread运行状态91进入Runner1运行状态76进入Runner1运行状态77进入Runner1运行状态78进入Runner1运行状态79进入Runner1运行状态80进入Runner1运行状态81进入Runner1运行状态82进入Runner1运行状态83进入Runner1运行状态84进入Runner1运行状态85进入Runner1运行状态86进入Runner1运行状态87进入Runner1运行状态88进入Runner1运行状态89进入Runner1运行状态90进入Runner1运行状态91进入Runner1运行状态92进入Runner1运行状态93进入Runner1运行状态94进入Runner1运行状态95进入Runner1运行状态96进入Runner1运行状态97进入Runner1运行状态98进入Runner1运行状态99进入Main Thread运行状态92进入Main Thread运行状态93进入Main Thread运行状态94进入Main Thread运行状态95进入Main Thread运行状态96进入Main Thread运行状态97进入Main Thread运行状态98进入Main Thread运行状态99 根据打印结果我们知道，run方法没有执行完毕是不会执行下面的代码的。而start方法则会和主线程进行交替执行，并不需要等start代码执行完毕。 总结： start()方法可以启动新的线程，而run()方法thread类的一个普通方法调用，还是在主线程里执行 start()能启动一个新的线程，run()不行 start()不能被重复调用；run()可以 star()中的run代码块可以不执行完就可以执行下面的代码，即使进行了线程的切换。直接调用run()方法必须等待其代码全部执行完才能继续执行下面的代码 start()实现了多线程；run()没有实现多线程 5.springMVC的执行流程？待完善","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://blog.gobyte.cn/categories/Java/"}],"tags":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://blog.gobyte.cn/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java集合框架系统学习","slug":"Java集合框架复习01","date":"2019-07-04T09:23:55.000Z","updated":"2023-10-07T08:53:25.031Z","comments":true,"path":"post/57eede11.html","link":"","permalink":"https://blog.gobyte.cn/post/57eede11.html","excerpt":"","keywords":null,"text":"写在前面：什么是Java集合-What？ Java集合是Java编程语言自带的功能。存放于java.util包下； Java集合其实可以分为三个小类：Set、List、Map 集合最大的目的是用来存储数据用的，不过存储的是数据的引用，也可以理解是内存地址。集合主要是便于开发者对数据进行增删改查等等操作，所以才会有“集合”这种东西。 为什么要学习集合-Why？ 笼统的说，学习集合最终是为了更好的开发程序 不负责任的说，是为了考试、面试 如何学习集合-How？ 学习集合的特点 学习集合的使用方法 学习集合的构成原理 这里我仅复习1和3，至于2需要在实际开发中渐进式学习。 学习集合框架，更多的是在于理解基础概念，再慢慢结合到实际编码中，所以少不了记忆。 集合框架的两大分类：Java集合框架可分为两大类Collection和Map，两者区别如下： Collection是单列集合；Map是双列集合 Collection中只有Set系列要求元素唯一；Map中键唯一，值可以重复 Collection的数据结构是针对元素的；Map的数据结构是针对键 Collection集合类Collection ：是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections：是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 如上图，Collection体系分为两大类：Set 和 List。例如以下Java代码使用工具类collections实现排序功能，当然还有很多其他功能 List集合List特点：存取有顺序；有下标索引；可以根据索引进行取值；元素也可以重复 ArrayList线程不同步；底层原理是数组；初始容量为10，当数组大小不足时，会自动扩充当前容量的1.5倍+1。ArrayList的元素内存地址是连续的，所以查询速度快。由于增删需要挪动数组内的数据，所以增删速度慢。为追求效率，ArrayList没有实现同步锁（synchronize）。若需要同步，可以手动添加同步锁，也可以用Vector代替。注意，Vector已经过时。 Vector（已过时）线程同步，但是效率低；容量不足时，默认扩充当前容量的一倍。 LInkedList线程不同步；双向链表实现；查询慢，增删快。查询慢是因为底层采用链表数据结构，而链表的内存地址不连续，所以查询慢。增删快是因为在增删时，不需要移动元素，只需要改变相关元素的头尾指针地址值。可以用来模拟栈和队列，栈是先进后出，而队列是先进先出。 LinkedList同时实现了List和Deque接口，可以将它看做一个顺序的容器，也可以看成一个队列（Deque）[^队列Deque]，同时还能看做成一个栈（Stack）^栈Stack。如果这样的话，LinkedList将是一个全能的超人。当你需要使用栈（Stack）和队列（Deque）时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是Java里根本没有一个叫做Deque的类（Deque是接口）。关于栈（stack）或队列（Deque），现在的首选是ArrayDeque，它有着比LinkedList（当栈stack和队列Deque使用时）更好的性能。 Set集合特点：存取无序；不可以重复；没有下标。 HashSet线程不同步，存取速度快，内部使用HashMap进行存储数据，且提供的方法基本都是调用HashMap的方法。所以两者本质相同，元素可以为Null。 Hash表是通过HashCode和equals方法保证唯一性。 Hash表存储元素的过程：首先根据被存储的元素来计算出HashCode值，然后根据计算出的HashCode值和数组的长度进行计算出存储的下标；如果该下标位置没有元素，则直接存储。如果有元素，直接用equals方法将被存入的元素和已有的元素进行对比，若结果为真则放弃储存。如果为假，则以链表的形式进行存储。 HashCode如何计算，请看这里：[如何重写HashCode方法](# 问：如何重写HashCode方法：) LinkedHashSet链表+Hash技术进行存储的，根据HashCode决定插入的位置，使用链表来维护次序。所以存取有序，又因为需要维护元素的顺序，所以比HashSet效率低；线程不安全 TreeSet线程不同步，底层原理使用二叉树结构^1，存储自然顺序[^2]，元素唯一，内部使用TreeMap的SortedSet。 TreeSet保证元素唯一性的两种方法： 自定义对象实现接口Comparable的comparaTo方法，该方法返回0表示相等，小于0表示准备存入的元素比被比较的元素小，否则大于0。 在创建TreesSet的时候向构造器中传入比较器Comparator接口的实现类，实现Comparator接口重写compara方法。 注意：如果存入自定义对象的时候，自定义类没有实现接口Comparable的comparaTo方法。或者也没有传入比较器Comparator，程序将会报错ClassCastException异常 Collection体系的总结：List ：存取有序，元素有索引，元素可以重复 ArrayList：数组结构，查询快，增删慢，由于线程不安全，所以效果比较高。 Vector：数组结构，查询快，增删慢，由于是线程安全，所以效率不如ArrayList 1addFirst() removeFirst() getFirst() Set：存取无序，元素没有索引，元素不重复 HashSet：存储无序，没有索引，元素不允许重复，底层由Hash表实现 TreeSet：存取无序，强制性排序，元素不能重复。 TreeSet有两种排序方式： 自然排序： TreeSet允许存入某些基础类型，它可以对这些类型自动升序排序[^2] 比较器排序-自定义排序： 如果要存入自定义的对象，则必须实现Comparable接口，覆盖它的compareTo()方法[^3] 问：Hash表是如何保证元素唯一性？​ 答：底层是依赖HashCode和equals。先将元素的HashCode计算出来，然后再使用equals进行对比元素。只有比对后不一致才开始存储，相等则放弃储存。 问：HashSet存储的步骤：​ 若存储的是自定义对象，需要在对象内重写HashCode和equals方法。因为HashSet存储时，会先调用HashCode方法来计算该对象的Hash值。然被存入的对象Hash值与已有的Hash值相同，则继续调用equals方法，equals方法的作用是对比两个对象，若结果相等，则放弃存储。否则在已有的对象下用链表形式存储。 问：如何重写HashCode方法：​ 通常在自定义HashCode的时候，只需要让当前对象的某个变动的值来关联一个随机数或者一个常量就可以，参考代码如下： 123456789101112@Overridepublic int HashCode()&#123; // 这里的99你可以根据你的喜好随便改一个整数，例如11，22都行 int result = 99; // 避免字段为空程序异常，所以先行判断 result = result * 13 + (name == null ? 0 : name.hashCode()); result = result * 13 + (sex == null ? 0 : sex.hashCode() ); result = result * 13 + (grade == null ? 0 : grade.hashCode() ); result = result * 13 + age; return result;&#125; 问：如何重写equals方法：​ 由于是自定义方法，至于如何保证两个元素相等这取决于开发者。举例现在定义了个Student类，这个类代表一个学生，如何判断两个学生对象是同一个学生？这就取决于开发者的要求了，若开发者认为只要学生的：姓名、年龄、性别、班级全部都相同时，认为是同一个人。此时在Student对象类里，重写equals方法，而equals应该去判断：姓名、年龄、性别、班级这些是否相等，从而返回一个布尔型Boolean的结果，实例代码如下： 12345678910111213141516@Overridepublic boolean equals(Object obj)&#123; // 1. 判断是否等于自身. if( this == obj ) return true; // 2. 使用instanceof运算符判断 Obj 是否为Student类型的对象. if( !(obj instanceof Student ) ) // 当是同一个类型，则不进入if return false; // 3.比较Student中的字段，判断值是否相同 Student newS = (Student) obj; //由于在步骤2的时候就已经判断是否为同类，若不是同类直接返回false，而程序也终止了，只有是同类型的时候才会走到这一行代码，所以不必要担心代码强转异常。 // 最后比较数据 retrun this.name.equals(newS.name) &amp;&amp; this.age == newS.age &amp;&amp; this.grade.equals(newS.grade) &amp;&amp; this.Sex.equals(newS.equals);&#125; 重写equals()而不重写hashCode()的风险在Oracle的Hash Table实现中引用了Bucket的概念．如下图所示： 从上图可以看出，带Bucket的HashTable大致相当于hash表和链表的结合体。即在每一个Bucket上挂一个链表，链表的每个节点都用来存放对象。Java通过hashCode()方法来确定某个对象应该位于哪个Bucket桶中，然后在对应的链表中查找。理想情况下，如果的HashCode()写的足够健壮，那么每个Bucket将会只有一个节点，这样就解决了查找操作的常量级别的时间复杂度，即无论你的对象放在哪片内存中，我们都可以通过HashCode()立刻定位到该区域，而不需要从头到尾遍历查找，这也是hash表的最主要的作用。 如：当我们调用HashSet的put(Object o)方法时，首先会根据o.hashCode()的返回值定位到相应的Bucket中，如果该Bucket中没有结点，则将 o 放到这里，如果已经有结点了, 则把 o 挂到链表末端。同理，当调用contains(Object o)时，Java会通过hashCode()的返回值定位到相应的Bucket中，然后再在对应的链表中的结点依次调用equals()方法来判断结点中的对象是否是你想要的对象。 不重写HashCode会导致相同内容的一个对象，在取出时为null。原因就是虽然两个对象内容相同，但是由于没有重写HashCode方法，导致默认调用Object类的HashCode方法，返回了对象的地址，而两个对象虽然内容是相同，但是地址不同，那么新的对象就去一个不存在bucket里寻找，自然是返回null。 参考自：[重写equal()时为什么也得重写hashCode()之深度解 我让hashCode()每次都返回一个固定的数行吗？示例代码： 1234@Overridepublic int hashCode() &#123; return 10;&#125; 如果这样，每次都返回相同的数值，那么HashMap、HashSet就失去了它应有的“哈希的意义”。用&lt;Effective Java&gt;中的话来说就是，哈希表退化成了链表．如果hashCode()每次都返回相同的数，那么所有的对象都会被放到同一个Bucket中，每次执行查找操作都会遍历链表，这样就完全失去了哈希的作用．所以我们最好还是提供一个健壮的hashCode()为妙． 参考自：如何重写hashCode()和equals()方法 Map集合Map是一个双列集合，其中保存的是键值对，键要求保持唯一性，值也可以重复。 键值是一一对应，一个键只能对应一个值。 Map的特点：存取无序，键不可重复。Map在存储对象的时候，将键传入Entry，然后存储Entry对象 HashMap线程不同步，键唯一且，键值均允许Null，值可重复，根据Key来计算HashCode进行存储。内部使用静态内部类Node的数组进行存储，默认初始长度是16，每次扩大当前容量的一倍。当发生Hash冲突时，采用链表进行存储。 在JDK1.8中：当单个桶Bucket中的元素个数大于8个时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止HashCode攻击。 Java HashMap 采用的是冲突链表方式。 HashMap 是 Hashtable 的轻量级实现，可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 不允许。 LinkedHashMap保存插入的顺序，在用iteration遍历LinkedHashMap时，先得到的记录肯定是最先插入的。也可以在构造时代入参数，按照应用次数进行排序。在遍历时会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据很少是，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历是和它的容量有关。 HashTableHashMap和它类似，随着Java发布它就一起发布了。而HashMap是JDK1.2才出现的。 它是线程安全，HashMap是线程不安全。而且它的键值都不允许存入Null。 TreeMap存入自定义对象为Key时，由于底层使用了二叉树，所以存入的对象都需要排序，若要排序，就需要有比较功能。所以自定义对象应该实现Comparable接口，或者给TreeMap对象传递一个Comparator接口。 脚注[^队列Deque]: 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。 [^2]: 自然排序：TreeSet内部默认使用了一个Java自带的方法java.lang.compareTo(e1, e2)进行比较大小，最后以升序进行排列。可以比较的类型是Byte，Double，Integer，Float，Long或Short，若存入的是这些类型，则会自动排序，所以也叫自然排序。[^3]:定制排序：若存入的是自定义对象，则无法进行比较大小，需要在自定义的类里实现Comparable接口，覆盖compareTo比较方法，自定义比较的规则。比较时需要创建第三方类，实现Comparator接口，并且覆其中的Compare()方法，编写比较规则和排序方式。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://blog.gobyte.cn/categories/Java/"}],"tags":[{"name":"java集合框架","slug":"java集合框架","permalink":"https://blog.gobyte.cn/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"Java面试复习巩固","slug":"Java基础复习巩固","date":"2019-07-04T06:51:03.000Z","updated":"2023-10-07T08:53:25.031Z","comments":true,"path":"post/47dfb631.html","link":"","permalink":"https://blog.gobyte.cn/post/47dfb631.html","excerpt":"","keywords":null,"text":"比较实用的面试总结应届生Java面试经验总结 - ShyTan的博客 两年Java开发工作经验面试总结 - 知乎 作为2020届的应届生，校招怎么准备的呢？ - 知乎 双非硕士的春招秋招经验总结——对校招，复习以及面试心态的理解 Java程序员面试复习手册 待整理的资料)记一次面试 Java 实习生的经历 数据库设计三大范式 盘点一下java面试中遇到的奇葩问题 GitHub笔试面试知识整理 牛客网-面试宝典 Java面试通关要点 汇总集【最终版】 应届生找工作，基础为主，项目在精 全栈教程合集 Java2018面试应届生常问题目-含金量高 Java校招面试题目合集_牛客网 集合一","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://blog.gobyte.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://blog.gobyte.cn/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"解决新浪/微博图床图片403错误防盗链问题","slug":"解决新浪-微博图床图片403错误防盗链问题","date":"2019-07-03T11:29:13.000Z","updated":"2023-10-07T08:53:25.041Z","comments":true,"path":"post/cfce32d8.html","link":"","permalink":"https://blog.gobyte.cn/post/cfce32d8.html","excerpt":"","keywords":null,"text":"缘由微博图床是网友利用新浪微博上传图片的功能，然后网友将图片的链接进行分享。微博图床的稳定性不用我多介绍，但是由于愈来愈多的网友使用微博做图床，微博官方可能觉得影响服务器或者费用的支出等原因，开始对微博图片添加了防盗链的功能。 新浪微博的图片防盗链：它的防盗链原理较为简单，只要不是新浪微博的白名单域名请求该图片，服务器会返回一个403的错误码。背后的原理是利用了浏览器的HTTP请求头默认会携带：Referer属性。而这个属性记录了该请求由哪个域名发送的。所以微博图床直接校验该属性的值，只要不是微博允许的域名访问图片链接，将会不予返回图片。下图是我博客请求一张图片的请求头： 可以看到该请求是由：https://blog.gobyte.cn/post/f9458eff.html发起的，而且这个Referer属性是浏览器默认携带，既然是默认携带，那肯定有关闭的方法。 解决方法1（不推荐）在HTML的&lt;head&gt;标签里添加mate标签，如下： 1&lt;meta name=\"referrer\" content=\"no-referrer\" /&gt; 不推荐该方法的原因是会导致该页面的所有的HTTP请求都不会携带Referer属性。这会导致部分功能失效，如某些统计信息失效，比如我使用了“不蒜子”的统计功能，会导致失效，所以我推荐方法2. 解决方法2-给图片添加referrerpolicy&#x3D;“no-referrer”（推荐）既然不能给所有的HTTP请求添加content=&quot;no-referrer&quot;，那么我们就仅给图片添加。 在img标签有个属性名叫referrerpolicy，给部分的HTTP请求添加Referer属性。 原生JavaScript语法： 12refStr = imgElt.referrerPolicy;imgElt.referrerPolicy = refStr; referrerPolicy可选值：123\"no-referrer\"：表示HTTP头部信息将不会发送 referrer 。\"origin\"：表示 referrer 只包含策略、主机名、端口等页面源的信息。\"unsafe-url\"： 这意味着引用者将包括源站和路径（但不包括片段、密码或用户名）。这种情况是不安全的，因为它可能会泄漏路径信息，这些信息已被使用TLS隐藏到第三方。 我对这三个值做了3次测试 ​ no-referrer-测试： origin-测试： unsafe-url-测试： 三者区别如上面三图所示，符合上面的“referrerPolicy可选值”描述。 所以我们只需要给img标签添加：referrerpolicy=&quot;no-referrer&quot;即可。 但是仅仅不可能每次都去手动添加，所以要么直接修改模板文件，要么写一段JavaScript，让页面加载HTML完成后，再对img标签进行遍历修改，话不多数，以下是我使用jquery完成的代码： 1234567891011121314var link = \"\" ;// 遍历所有的img标签$(\"img\").each( (i,o) =&gt; &#123; var o = $(o); // 判断图片的链接是否包含sinaimg关键字 if( o.attr(\"src\").indexOf(\"sinaimg\") &gt; 0 )&#123; // 给这个标签加上referrerPlicy属性 o.attr(\"referrerpolicy\",\"no-referrer\"); // 备份图片的src link = o.attr(\"src\"); // 重新设置src，让页面重新加载一次图片 o.attr(\"src\",link); &#125;&#125;); 注意：这段JavaScript代码需要放在HTML的底部，所以当HTML第一次加载完图片的时候，不出意外的话console控制台依然会报403错误，因为首次加载图片的时候JavaScript脚本并没有给img添加该属性，所以理所当然的是403。但是如果把JavaScript代码放在页面的顶部，那么会因为图片的img标签晚于JavaScript的执行，导致JavaScript代码找不到img标签会让功能不生效。 操作方法： 找到你的主题的JavaScript代码，我是使用pure主题 我这主题的修改目录：hexo\\pure\\layout\\_common\\script.ejs里添加上述代码 最终修改结果如下： 使用其他主题的同学请自行查找对应的文件修改 当然，如果你知道如何修改Hexo的页面模板，直接在模板里给图片标签加上referrerpolicy=&quot;referrerpolicy&quot;也可以，但是我不知道如何修改。所以我还提供了方法3。 解决方法3-在生成HTML的时候加上referrerpolicy&#x3D;”referrerpolicy”注意，因为我是使用Hexo博客程序，该博客是使用markdown编写文章，最后由HEXO程序进行渲染出HTML文件。所以我直接在markdown里标注要需要添加：referrerpolicy=&quot;referrerpolicy&quot;的图片，渲染的时候直接添加该属性。 而Hexo提供了一个自定义函数的功能，操作方法： 在你的Hexo程序目录的“script”文件夹里（如没有自己新建），创建一个文件“myFunction.js” 复制以下JavaScript代码到该文件内 12345// 给img添加referer policy 标签，解决referer图片防盗链hexo.extend.tag.register('s', function(args)&#123; const image_url = args[0], alt = args[1]; return `&lt;img src=\"$&#123;image_url&#125;\" alt=\"$&#123;alt&#125;\" referrerpolicy=\"no-referrer\"&gt;&lt;/img&gt;`&#125;) 在markdown里使用 &lt;% s 图片url alt说明 %&gt;调用。调用代码示例： 1&#123;% s https:&#x2F;&#x2F;ws4.sinaimg.cn&#x2F;large&#x2F;96e311f0gy1g3uyql0zj0g20s60lmn71.gif 删除效果 %&#125; 页面地址为：点我打开效果页面，效果图如下：该方法适用于偶尔使用微博图床；因为使用了自定义语法的功能，导致markdown编写的时候不能预览图片。而且每次书写自定义代码尤为的不方便，我个人不太建议使用。 总结：微博这次加了图片防盗链，虽然是很简单的防盗措施，但是也说明了微博对于图片外链的态度，不喜欢网友使用他们的服务器架设图床，所以以后也可能会有更加厉害的防盗链方法也是可能的。 我个人建议各位同学还是架设一个自己的文件存储系统，至少图片不会有丢失、无法访问的风险，目前各大云服务提供商都有免费的套餐，大家可以了解一下。 本篇文章也是个人思考的总结，最后感谢你的耐心阅读。","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]},{"title":"spring-boot部署到CentOS服务器、安装Redis、配置Nginx、MySQL","slug":"spring-boot部署到服务器以及安装Redis","date":"2019-07-01T16:39:26.000Z","updated":"2023-10-07T08:53:25.035Z","comments":true,"path":"post/c621cb41.html","link":"","permalink":"https://blog.gobyte.cn/post/c621cb41.html","excerpt":"","keywords":null,"text":"部署到服务器 使用idea的Maven工具，package命令，即可对项目进行打包。也可以手动输入maven命令打包mvn clear package 打包完成以后，是一个jar文件，会存放在你项目的target目录下。我通过WinSCP软件上传到我的阿里云服务里。 项目需要用到Redis，所以我还把Redis压缩包上传到了服务器内，参考了该教程进行安装。Centos7下安装redis - 醉东风 在设置Redis开机自动启动过程中，使用命令启动和停止Redis命令时，碰到了报错：env: &#x2F;etc&#x2F;init.d&#x2F;redisd: Permission denied 12[root@github init.d]# service redisd startenv: /etc/init.d/redisd: Permission denied 最后解决方法是： 1234chmod a+x /etc/init.d/redisa+x 是给所有人加上可执行权限，包括所有者，所属组，和其他人o+x 只是给其他人加上可执行权限 配置nginx第一种方法（不推荐）由于已经有了一个tomcat项目，所以第二个项目必须要在nginx里添加配置，否则访问就需要加端口访问了，我的配置如下： 123456789# 第二个项目 location ^~ /apply &#123; #转发给tomcat处理 proxy_pass http://127.0.0.1:9090/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; 我的nginx配置文件目录是/etc/nginx/nginx.conf，如果你不知道，可以使用find / -name nginx.conf命令进行全局搜索。 解决nginx的SpringBoot 静态文件404问题： 单独匹配项目还不够，还需要**匹配项目的静态文件**，否则你的css和js等静态文件加载会出现404的情况，我的匹配规则如下： 123 location ~ \\.(css|html|htm|js|gif|jpg|jpeg|png|bmp|swf)$ &#123; proxy_pass http://127.0.0.1:9090; &#125; 最后记得重新加载nginx配置，命令：nginx -s reload 第二种方法2019-7-2 19:42:50更新： 第一种方法有弊端。因为项目的请求链接基本是固定的。 例如项目的登陆地址是：www.gobyte.cn/login 如果使用了第一种，那么必须加一个目录：www.gobyte.cn/xxx/login。 而多了一层目录以后，预先项目的请求地址实际上还是www.xxxx.cn/login。仅仅只是匹配了xxx只能解决页面的加载，实际post的时候会导致404，如果不想404，就只能把所有的请求都转发。那样其他的项目就会发生冲突。或者修改项目的post请求，给请求也加上/xxx/目录，但是这样弊端很大，因为需要改动源代码，所以可以通过第二种方法，使用二级域名来对应新的项目。 添加dns解析，例如我第二个项目打算使用二级域名为：b.gobyte.cn，那么把dns的解析为b，至于记录值还是你的服务器ip 修改nginx.conf配置： 1234567891011121314151617# 第二个项目 server &#123; listen 80; #你要监控的端口。https是监控443 server_name b.gobyte.cn; #填写你要项目域名 index index.html index.htm index.php default.html default.htm default.php; location / &#123; proxy_pass http://127.0.0.1:9090; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; nginx -s reload 进行重新加载nginx配置 参考：nginx在一个服务器上配置两个项目，并通过两个不同的域名访问 找回MySQL密码我MySQL安装很久了，但是很少使用，所以密码也不记得。 尝试使用MySQL登陆，结果提示被拒绝：ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO) 使用命令停止MySQL服务：systemctl stop mysqld 用以下命令启动MySQL，以不检查权限的方式启动：mysqld --skip-grant-tables &amp; 登录mysql：mysql -uroot或mysql 登陆MySQL后，使用 \\s命令查询MySQL版本号 12345678910111213141516171819202122232425mysql&gt; \\s--------------mysql Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using EditLine wrapperConnection id: 4Current database:Current user: root@localhostSSL: Not in useCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.24 MySQL Community Server (GPL)Protocol version: 10Connection: Localhost via UNIX socketServer characterset: latin1Db characterset: latin1Client characterset: utf8Conn. characterset: utf8UNIX socket: /var/lib/mysql/mysql.sockUptime: 6 min 22 secThreads: 1 Questions: 20 Slow queries: 0 Opens: 110 Flush tables: 1 Open tables: 105 Queries per second avg: 0.052--------------mysql&gt; 然后更新root密码 12345mysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD('root') where USER='root';mysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD('root') where USER='root'; 刷新权限：flush privileges; 退出mysql命令：exit或quit 使用root用户重新登录mysql 1mysql -uroot -proot 参考自：解决MySQL登录报ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)的问题 CentOS7开启MySQL远程访问 点击查看完整的脚本命令 12345678910111213141516[root@github ~]# mysql -uroot -proot #登陆MySQLmysql&gt; use mysql #选择MySQL表Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update user set host='%' where user='root' and host='localhost'; #修改登陆主机Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; UPDATE user SET password=password(\"root\") WHERE user='root'; #重新设置一下密码，因为这时密码已失效，虽然本地还可以原密码登录，可远程改了host后还是没法访问mysql&gt; flush privileges; #刷新权限Query OK, 0 rows affected (0.00 sec)mysql&gt; exit #退出 MySQLBye[root@github ~]# service mysqld restart; #重启MySQLRedirecting to /bin/systemctl restart mysqld.serviceJob for mysqld.service failed because the control process exited with error code. See \"systemctl status mysqld.service\" and \"journalctl -xe\" for details. 参考：[CentOS7和CentOS6怎样开启MySQL远程访问](https://blog.csdn.net/u014066037/article/details/55194802) 总结： 打包SpringBoot 项目使用：mvn clean package 在Linux 启动项目使用命令：nohup java -jar xxx.jar &amp; ；停止运行使用:ps -ef|grep xxxx.jar查询出pid，然后使用：kill -9 pid命令杀死进程，你还可以使用脚本来管理程序： 点击展开完整的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/bash#这里可替换为你自己的执行程序，其他代码无需更改APP_NAME=apply-0.0.1-SNAPSHOT.jar#使用说明，用来提示输入参数usage() &#123; echo \"Usage: sh 执行脚本.sh [start|stop|restart|status]\" exit 1&#125;#检查程序是否在运行is_exist()&#123; pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '&#123;print $2&#125;' ` #如果不存在返回1，存在返回0 if [ -z \"$&#123;pid&#125;\" ]; then return 1 else return 0 fi&#125;#启动方法start()&#123; is_exist if [ $? -eq \"0\" ]; then echo \"$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .\" else nohup java -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp; fi&#125;#停止方法stop()&#123; is_exist if [ $? -eq \"0\" ]; then kill -9 $pid else echo \"$&#123;APP_NAME&#125; is not running\" fi &#125;#输出运行状态status()&#123; is_exist if [ $? -eq \"0\" ]; then echo \"$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;\" else echo \"$&#123;APP_NAME&#125; is NOT running.\" fi&#125;#重启restart()&#123; stop start&#125;#根据输入参数，选择执行对应方法，不输入则执行使用说明case \"$1\" in \"start\") start ;; \"stop\") stop ;; \"status\") status ;; \"restart\") restart ;; *) usage ;;esac 安装和设置Redis参考该教程：Centos7下安装redis - 醉东风 多个项目，可以使用反向代理Nginx工具，它的优点是支持80端口访问多个项目；负载均衡（目前我没用上）；反向代理其他服务器（例如反向代理新浪微博做图床）等等 MySQL密码也忘了，后面还要更新下找回MySQL密码。 已经在2019-7-2 18:32:12更新。 找回MySQL密码","raw":null,"content":null,"categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.gobyte.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.gobyte.cn/tags/nginx/"}]},{"title":"入门-利用Java免费使用百度人脸识别对妹纸进行打分","slug":"入门-免费使用百度人脸识别api对妹纸进行打分","date":"2019-06-29T10:41:07.000Z","updated":"2023-10-07T08:53:25.037Z","comments":true,"path":"post/7294a25e.html","link":"","permalink":"https://blog.gobyte.cn/post/7294a25e.html","excerpt":"","keywords":null,"text":"介绍意外发现了学校某个系统的漏洞，可以不鉴权查看考生的照片。所以我通过一段java代码将这些照片给下载到电脑上。当我看到这些照片的时候，另一个想法便出现了，就是利用目前的人脸识别技术给这些照片来打个分。 操作流程 注册百度智能云账户 在：产品服务 &#x2F; 人脸识别 里，建立一个自己的应用 打开官方文档，根据步骤操作，重要的是你需要把代码里的APP_ID ,API_KEY ,SECRET_KEY 替换成你自己的，这些是在你步骤2的时候创建成功就能看见。 完成上述三步，即可以开始测试了。通常测试的图片需要转成base64编码，所以此时可以利用Java的IO方法读取硬盘里的图片和Java自带方法BASE64Encoder对图片进行编码. 程序运行流程 读取硬盘图片以及转换成base64编码的代码： 1234567891011121314 public String getImgBase64(String filePath) &#123; byte[] data = null; try &#123; InputStream in = new FileInputStream(filePath); data = new byte[in.available()]; in.read(data); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; BASE64Encoder encoder = new BASE64Encoder();// System.err.println(encoder.encode(data)); return encoder.encode(data); &#125; 人脸识别数据写入到txt内： 12345678910111213141516public void appendJson(String str, String filePath) &#123; BufferedWriter bw = null; try &#123; bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath, true))); bw.write(str + \"\\r\\n\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bw.flush(); bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的主体： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 //设置APPID/AK/SK public static final String APP_ID = \"你的 App ID\"; public static final String API_KEY = \"你的 Api Key\"; public static final String SECRET_KEY = \"你的 Secret Key\"; public static void main(String[] args) &#123; feceServerImpl faceServer = new feceServerImpl(); // 初始化一个AipFace AipFace client = new AipFace(APP_ID, API_KEY, SECRET_KEY); Map&lt;String, Object&gt; msg = new HashMap&lt;String, Object&gt;(); // 可选：设置网络连接参数 client.setConnectionTimeoutInMillis(2000); client.setSocketTimeoutInMillis(60000); // 可选：设置代理服务器地址, http和socket二选一，或者均不设置// client.setHttpProxy(\"proxy_host\", proxy_port); // 设置http代理// client.setSocketProxy(\"proxy_host\", proxy_port); // 设置socket代理 // 遍历指定文件夹 String path = \"E:\\\\downloadImg\\\\\"; File file = new File(path); File[] files = file.listFiles(); for (File f : files) &#123; if (!f.isDirectory()) &#123; // 调用接口 String image = faceServer.getImgBase64(f.toString()); // 指定图片的类型 String imageType = \"BASE64\"; // 传入可选参数调用接口 HashMap&lt;String, String&gt; options = new HashMap&lt;String, String&gt;(); // 这个是指定服务器返回的参数，其中age代表要检测年龄；beauty是检测颜值 options.put(\"face_field\", \"age,beauty\"); options.put(\"max_face_num\", \"1\"); options.put(\"face_type\", \"CERT\"); // 人脸检测 JSONObject res = client.detect(image, imageType, options); // 将服务器返回的数据转成map，方便操作 Map&lt;String, Object&gt; stringObjectMap = res.toMap(); // 删除不必要的数据 stringObjectMap.remove(\"log_id\"); stringObjectMap.remove(\"error_msg\"); stringObjectMap.remove(\"cached\"); stringObjectMap.remove(\"error_code\"); stringObjectMap.remove(\"timestamp\"); // 添加照片的名字到map里，方便知道这条数据对应的哪张照片 stringObjectMap.put(\"照片\", f.toString()); System.out.println(res.toString(1)); // 将评分数据写入到txt文件内 faceServer.appendJson(stringObjectMap.toString(), \"e:\\\\imgJson.txt\"); // 防止QPS超限，进行延迟 try &#123; Thread.currentThread().sleep(500);//毫秒 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //break; &#125; &#125; &#125; 整理数据将由代码保存的到硬盘txt文本数据，复制到Excel里借用排序工具进行整理，便可以知道哪张图片的颜值最高。最终整理的数据如下图： st=>start: 开始 e=>end: 结束 op1=>operation: 遍历文件夹内图片 op2=>operation: 读取文件并Base64编码 op3=>operation: 人脸识别 op4=>operation: 接收人脸识别的信息 op5=>operation: 删除不需要的信息 op6=>operation: 保存信息到txt文件 cond=>condition: 是否遍历完成？ st->op1->op2->op3->op4->op5->op6->cond cond(yes)->e cond(no)->op1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"https://blog.gobyte.cn/categories/Java/"}],"tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"https://blog.gobyte.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"}]},{"title":"篡改页面的Js代码，从而达到\"为所欲为\"的目的","slug":"篡改页面的Js代码，从而达到为所欲为的目的","date":"2019-06-23T02:41:39.000Z","updated":"2023-10-07T08:53:25.040Z","comments":true,"path":"post/32b605b3.html","link":"","permalink":"https://blog.gobyte.cn/post/32b605b3.html","excerpt":"","keywords":null,"text":"声明本教程仅适用于技术交流学习，切勿用作违反国家法律法规等途径，否则应由操作人承担，本作者不承担任何责任。本教程仅做科普，如果你认为自己已经领会，还请勿喷，不要以“幸存者偏差”视角来看待任何事物。 缘由不少网站都是通过JavaScript来判断用户的输入数据，通常我们是自己构造一个Http的请求，来跳过这些JavaScript验证，但是这样需要你掌握Http请求中的各个参数的构造，所以比较繁琐。 那么如何在不模拟Http请求的情况下跳过这些验证？答案当然有！使用浏览器的开发者工具进行对页面的JavaScript代码修改。我使用带有Chromium内核的浏览器，篡改JavaScript代码之前，应该先找到需要篡改的关键JavaScript代码。我一般是通过监听对应的事件来找到对应的JavaScript代码。 调试方法1 例如我需要监听Click事件，那么按下F12打开“开发者工具”，切换到“Sources”选项页面，在右侧的菜单栏里找到“Event Listener Breakpoints”，依次点击“Mouse”分类 &#x3D;&gt; “Click”，勾选，如下图： 点击页面的按钮，从而浏览器会自动跳转到JavaScript代码。接着在“Sources”页面内的右侧，会有一排调试按钮可供我们使用 上面这种调试方法我并不推荐，因为调试过程中的不相关代码太多，很难找到我们需要的关键代码。通常我是用下面一种方法。 调试方法2 以该页面为例，我需要篡改对身份证号的判断 通过开发者工具，定位该输入框，查看它的“Element”页的详细信息： 可以看到该输入框有id，但是没有class，根据经验判断。本页面的JavaScript代码应该是通过id来获取该输入框内的Value，所以我们使用“开发者调试工具”的全局搜索功能，搜索这个id名“txtCard”，从而能快速定位到对应的JavaScript代码。 快捷键Ctrl + Shif + F，搜索结果如图： 我们可以点击上面的搜索结果，从而能跳转到对应的JavaScript源码。例如上图有两个文件，分别为Sign.js和yidong.html。43行的这个结果肯定不匹配。27行的注释，也可以忽略。那么55行的这个trim方法很关键，用过JavaScript的朋友都知道这个方法是取出字符串的前后空格的，通常是用来取值。所以我们直接点击55行，效果如下图： 可以根据上步骤得知，最终身份证号赋值给变量CentNo，继续搜索CentNo，结果如下图： 在页面输入错误的身份证号，会有提示：“请输入正确的身份证号”。所以步骤6的搜索结果应该选择第81行的代码，如下图： 简单看了一下81行代码，它是一个if判断，判断内调用一个检查身份证号方法，从而来拦截页面不合法的操作。这里我们只需要将if内的取反符号!删除，即可跳过不合法身份证号的判断了，删除后记得按下快捷键Ctrl + S保存。页面的文件名前面将会出现一个感叹号ICO，如下图： 最后，点击提交，测试一下篡改JavaScript代码是否生效~ 我测试通过，如下图：代码已经执行100行结束了，准备执行下一个if，说明100行的if修改成功。另外还有一个判断成功的方法就是页面会发送http请求到服务器，所以network选项里会有数据包，如下图： 最后，页面出现喜闻乐见的弹窗提醒 通过本文，作为后端程序员，一定不可相信前端数据的合法性，一定要再次进行校验，本文完。","raw":null,"content":null,"categories":[{"name":"骚操作","slug":"骚操作","permalink":"https://blog.gobyte.cn/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.gobyte.cn/tags/JavaScript/"}]},{"title":"教你\"自定义\"选择手机号码","slug":"教你自定义选择手机号码","date":"2019-06-18T12:59:14.000Z","updated":"2023-10-07T08:53:25.038Z","comments":true,"path":"post/55ff314c.html","link":"","permalink":"https://blog.gobyte.cn/post/55ff314c.html","excerpt":"","keywords":null,"text":"声明本教程仅以技术交流为前提，不得违反法律法规，否则一切责任由操作者自行承担。 1. 缘由起初是自己在网上购买一张手机卡准备自己使用，但在激活的过程中我发现手机号可以自由选择的。激活时，系统会提供一个号码的页面，页面里有几十个号码可供挑选，并且可以“换一批”，于是我打算“自定义”手机号试一试，当然这个“自定义”并不可能完全的自己去编写你想要的手机号，而是在系统提供的所有号码中，选择你最喜欢的一个。一般而言，系统会提供几千至几万个号码可供挑选，所以比你在页面的选择余地大了很多倍。 号码列表如下图： 2. 如何找到所有的号码？通过分析电脑浏览器，分析页面，可以得知浏览器会向服务器请求一些参数，然后服务器会根据参数返回一些手机号。具体参数如下图： 一共有9个参数，我们只需要关心pageSize这个参数即可。因为它代表着我们一次能获取多少个号码。 3. 那么如何知道目前号码池一共有多少个手机号呢？答案也非常简单。 当我把上述参数配置好以后，请求服务器，服务器会返回JSON格式的字符串，具体如下： 123456789101112131415161718192021222324252627282930313233343536&#123;\"bean\": &#123; \"cityCode\": \"0816\", \"hss\": \"HL***\", \"pageCount\": \"10922\", \"pageNum\": \"1\", \"pageSize\": \"5\", \"phoneType\": \"0\", \"phoneTypeName\": \"非三同\", \"provCode\": \"280\", \"reginCode\": \"12\", \"stateType\": \"28\", \"totalCount\": \"54610\", \"transactionId\": \"1085**********************\"&#125;,\"beans\": [&#123; \"phoneNo\": \"15196263985\"&#125;,&#123; \"phoneNo\": \"18780353629\"&#125;,&#123; \"phoneNo\": \"15182301620\"&#125;,&#123; \"phoneNo\": \"15892655729\"&#125;,&#123; \"phoneNo\": \"15281683225\"&#125;],\"returnCode\": \"0000\",\"returnMessage\": \"号码列表查询成功\",\"timeStamp\": \"1560863581187\"&#125; 上述的JSON字符串中，带*符号的我替换了。此时我们应该注意到totalCount字段。该字段其实就是代表目前号码池有多少个号码，也就是说，在我本次请求服务器后，目前号码池一共有54610个号码可以供我们选择。 既然知道了号码池总数，剩下的是我们只需要把该号码都请求出来，然后直接挑选即可。 4. 请求号码池内的所有号码回到步骤2，修改请求参数字段pageSize,把值改成54610 所以最终参数应该如下： 123456789hss: HL***provCode: 280cityCode: 0816pageNum: 1pageSize: 54610phoneType: 0transactionId: 10852*****************stateType: 28reginCode: 12 最后发送请求至服务器，不出意外的话，服务器将会返回给我们一个携带有54610个号码的JSON字符串，如下图： 5. 处理&#x2F;筛选号码由于号码都是json格式，这个时候我们应该对号码进行处理，以便于后续能够被靓号筛选软件使用。 处理该json格式的字符串我使用的是文本编辑器“editplus”，你们也可以使用“notepad++”。 处理方法简单： 在页面上全选所有内容、复制 打开editplus，粘贴 选择字符串：&quot;},{&quot;phoneNo&quot;:&quot;，Ctrl+H快捷键，替换 替换时，勾选“使用正则表达式” 修改字符串：&quot;},{&quot;phoneNo&quot;:&quot;，让它不被正则表达式转义，最终为：\\&quot;\\},\\{\\&quot;phoneNo\\&quot;:\\&quot; 增加替换的内容为：\\n，这个是换行键的转义符。通常一个回车键是由”换行+回车“两种符号组成。但是在editplus软件中，只需要有换行符号就行，所以我们只需要填写\\n，其他的软件可能要填写成\\r\\n。这些只要学过编程的同学，应该都知道。再说一个小知识点，win下换行符是\\r\\n（两个字符）；Linux 下换行符是 \\n；Mac 下换行符是 \\r 最后，点击“全部替换”按钮 最终替换界面和替换效果如下图： 6. 利用软件，筛选出靓号在第五步骤的时候，已经把json字符串中不必要的文本已经替换成换行了，接下来是利用软件，对这些号码进行筛选，从而能分辨出那些是靓号。 靓号筛选软件比较多，我这里不做推荐，有兴趣的同学可以自行搜索一下，我贴出我的筛选成果，如下图： 7. 使用浏览器的开发者工具，进行选号上一步骤中，我们已经成功的筛选出心怡的手机号了。此时我们利用浏览器的开发则工具，修改页面里 将页面里的号码，修改我们从号码池里挑选出来的号码，然后点击。 此时浏览器会继续向服务器发送请求，当然发送的号码就是你刚刚修改的号码。 后续就是按照流程上传你本人的身份证照片，以及人脸视频，然后耐心等待认证成功的短信提醒。 总结：“自定义”号码主要是从号码池中选择你喜欢的号码，并不是真正的自定义。本文主要是提供一个思路，让你能够在短时间内获取号码池的所有号码，从而达到”自定义“的目的，所以本文中的关键信息都已经被隐去。另外阅读本文需要少许的编程知识，希望通过本文能够给你带来不一样的体验。 最后感谢占用您宝贵的时间来阅读本文，如有问题还请留言，我将知无不言。","raw":null,"content":null,"categories":[{"name":"骚操作","slug":"骚操作","permalink":"https://blog.gobyte.cn/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"自定义手机号","slug":"自定义手机号","permalink":"https://blog.gobyte.cn/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%8B%E6%9C%BA%E5%8F%B7/"}]},{"title":"netlify服务器自定义域名添加自定义证书开启HTTPS的正确方法","slug":"netlify服务器添加自定义证书开启HTTPS的正确方法","date":"2019-06-13T03:34:17.000Z","updated":"2023-10-07T08:53:25.035Z","comments":true,"path":"post/b5463510.html","link":"","permalink":"https://blog.gobyte.cn/post/b5463510.html","excerpt":"","keywords":null,"text":"什么是netlify？netlify和GitHub pages 的作用一样，托管静态代码的服务器，可以参考我这一篇文章：GitHub pages开启Https、自定义域名和CDN加速。说直白点，就是存放HTML等静态文件的服务器。 为什么要选择netlify？根据我使用了不到一天的体会， netlify的速度更快。服务器多，我通过工具查询，netlify提供了7、8个的IP提供用户访问。相比较GitHub的5个ip，它的访问速度远高于GitHub。 它支持添加多个自定义的域名。 持一键开启HTTPS服务（使用的是Let’s Encrypt提供的证书，需要修改域名的CANME解析） 支持添加自定义证书 支持自动部署（不再需要自己生成html文件再deploy到服务器） 由于截止写稿时使用时间过短，所以难免还有地方没有表达完整，请见谅。 如何开启自定义域名的https服务？ 部署博客程序到GitHub 通过GitHub注册netlify 通过netlify读取GitHub上面的博客程序，并自动部署 因为如何部署至netlify不在本文的重点，所以上述三个步骤还请自行搜索解决，另外我也相信你可以做到的，加油！ 部署完毕以后，我们进入到项目的settings里 找到settings菜单，并点击 找到 Domian management ，并点击 找到 Costom domains ， 这个就是自定义域名项目 向下翻滚，找到 Add domain alias ， 这个按钮就是添加自定义域名了。 这个时候就可以添加你的域名了。例如我添加的是：blog.gobyte.cn，效果见上图。 使用腾讯云，申请免费的SSL证书这里提一句，为什么我不直接使用netlify的证书，而是自己单独去申请一个。上面提到过，netlify使用它的自定义域名的https时，需要你修改域名的CANME指向netlify提供给你的二级域名上，具体可以看官方的文档说明： SSL &#x2F; HTTPS | Netlify DOMAIN ALIASESYour certificate will include all your domain aliases when it’s issued, but note that DNS also needs to be configured IN ADVANCE for all aliases for us to include them on your certificate. See the troubleshooting section below for more information on confirming the new configuration. 为了大家能顺利的阅读，翻译成中文如下： 域别名选项您的证书在发出时将包含所有域别名，但请注意，还需要预先配置DNS，以便我们将所有别名包含在您的证书中。有关确认新配置的更多信息，请参阅下面的故障排除部分。 其实上面的翻译不算准确。准确的说是把域名的主机记录，通过CANME指向它提供二级域名，例如提供给我的netlify二级域名是：shanlan.netlify.com。其实不把域名的CNAME指向它的二级域名也是可以访问的，只不过它的页面会提示你检查DNS解析配置，如下图 。 那么我为什么还要坚持去使用第三方的域名？原因是我需要启用CDN，而CDN分发的时候需要回源。我希望回源能用上https，所以我就需要提供证书给CDN，而使用netlify的证书，我没办法去下载。那么干脆就自己去申请证书然后添加到netlify上面吧。 腾讯云的免费证书申请方法见我这篇文章：GitHub pages开启Https、自定义域名和CDN加速，我这里不再赘述。 亚洲诚信的证书如何配置到netlify？ 根据上图的netlify添加自定义证书输入框来看，它需要三种数据，分别如下： PEM格式证书 . 私钥KEY CA证书链 CA certificate chain 我们来看下从腾讯云下载的亚洲诚信证书的压缩包： 该证书压缩包提供了四种主流服务器程序的证书，分别为： apache服务器 IIS服务器 nginx服务器 tomcat 服务器 我翻遍了这4个文件夹，没有找到.PEM格式的文件怎么办？通过查询netlify官方文档，我看到了这样描述： Custom CertificatesIf you already have a certificate for your domain and prefer that to Netlify’s domain-validated certificate, you can install your own. To install a certificate, you’ll need: the certificate itself, in X.509 PEM format (usually a .crt file) the private key you used to request the certificate a chain of intermediary certificates from your Certificate Authority (CA) 翻译成中文如下： 自定义证书如果您已拥有域名证书并且更喜欢Netlify的域验证证书，则可以安装自己的证书。 要安装证书，您需要： 证书本身，采用X.509 PEM格式（通常为.crt文件） 您用于请求证书的私钥 来自证书颁发机构（CA）的一系列中间证书 上面描述的很清楚，需要PEM格式，通常为.crt文件 好的，CRT文件在压缩包里有好2个，分别为apache和nginx里，正好他们两个都有key文件。 但是，选项3的CA证书链 CA certificate chain 去哪里找？搜索一番得知，一般会在证书申请成功以后通过email 发送给使用者。但是我看了下腾讯云给我发送的邮件，是没有该内容的。 申请证书后，我们会发一封颁发邮件，在颁发邮件里，有证书链代码，把代码保存为crt后缀的txt文本里就可用了 终于在耗费两个多小时后，我打开了亚洲诚信的官网，通过在线聊天功能，联系上了他们的技术顾问，并说明了我的情况，在这位技术同学的帮助下，我成功的收到了亚洲诚信提供的CA证书链 CA certificate chain 在这里，由衷的感谢一下技术同学“Huang Nome”的帮助，祝他生活愉快 开始添加https证书通过尝试apache服务器和nginx服务器的证书，只有nginx文件夹内的证书能添加成功 打开从腾讯云下载的证书压缩包，打开nginx的文件夹 以文本模式，打开文件夹内的.CRT文件，并复制粘贴到netlify的PEM输入框内 以文本模式，打开文件夹内的.KEY文件，并复制粘贴到netlify的KEY输入框内 复制由“亚洲诚信”提供的CA证书链文本，粘贴到netlify的Intermediate certs内 点击“Install certificate”完成添加。成功效果图如下： CDN设置https回源我使用的是腾讯云CDN，操作如下图： 至此，教程已经结束，感谢阅读。","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]},{"title":"GitHub pages开启Https、自定义域名和CDN加速","slug":"GitHub-pages开启Https、自定义域名和CDN加速","date":"2019-06-12T09:56:56.000Z","updated":"2023-10-07T08:53:25.030Z","comments":true,"path":"post/bc0a861a.html","link":"","permalink":"https://blog.gobyte.cn/post/bc0a861a.html","excerpt":"","keywords":null,"text":"GitHub page是什么？我只是简短讲一讲自己的理解，更详细的还请自行搜索，如果错误还请指出。 GitHub pages 是一个能存放静态资源的服务器。你可以把它当做apache服务器使用。同时支持使用自定义域名解析，而且也支持HTTPS加密访问。 但是如果用上了CDN服务器，它这个HTTPS加密就无法使用了，具体请看图： 为什么不能使用Https访问？上面试验过了Https访问浏览器会报错“不安全”，原因是因为该证书它是由CDN服务器提供给CDN域名的。当我们使用自己的域名去访问https的时候，当然会报错。 如何将解决？我使用的是腾讯云的CDN，有免费流量，我是用不完的。同时腾讯云还提供免费的SSL证书，也就是HTTPS证书使用。另外我将自己的域名DNS服务器设置为dnspod，也就是腾讯云的dns解析，这样后面设置的时候也会方便不少，同时dnspod口碑也不错。 2019年12月19日10:41:15更新： 现在需要做的是： 腾讯云申请证书 给CDN安装上申请的证书 将自己的域名通过CNAME指向腾讯云提供的域名-参考下面的《设置CDN服务》标题的步骤6 测试访问 其实，我已经探索到了更快更方便的方法：使用coding的page，因为coding是腾讯的产品，服务器都在香港，比GitHub速度要快，另外coding团队&#x2F;企业版有CLI功能，能实现自动编译，所以hexo写文章后只需要push而无需在deploy了。至于速度你可以尝试访问我的博客：blog.gobyte.cn体验一下，而且我没有启用CDN 建议读到这里的朋友，可以考虑把博客切换到国内的git平台吧，毕竟上面的人不希望我们再继续使用国外的服务了（具体参考GitHub的访问速度），识时务者为俊杰。 1. 创建证书 打开腾讯云-云产品-SSL证书-申请免费证书-亚洲诚信（写稿时是亚洲诚信提供的SSL证书）-确定 通用名称；输入需要加证书的域名，例如我需要给”test.gobyte.cn“加上证书，那么在”通用名称“里输入”test.gobyte.cn“即可 申请邮箱；自己的邮箱，我是填QQ邮箱，因为电脑每次都会登陆QQ 证书备注名；自己随便写 私钥密码；我嫌麻烦，没有设置 所属项目；默认项目 最后设置如图： 2. 域名验证域名验证一共有三种方式，如果你的DNS解析服务器是腾讯云的，那么可以使用第一种自动验证。 自动DNS验证；原理是它自动帮你创建一条TXT解析，来进行验证。但是我试过，自动验证需要耗费十几分钟甚至更久才能验证通过。而且证书创建后一小时内不可删除，所以不建议使用。 手动DNS验证；会提供一个二级域名和一串字符串，让你去dns解析里添加，建议使用 文件验证；在你的网站里创建一个文件，文件内同样是指定的一串随机的字符串，网站如果变动了验证会失效，不建议 3. 添加DNS解析完成验证 进入你的域名解析管理 添加记录；主机记录如图：_dnsauth.test ；记录类型：TXT；记录值：201906111036051a20pp0b9x741e6lkn3xa302034gai8q61314oiyu4zogq8r1x ；最终效果如下图： 回到证书详情页面，点击刷新按钮，查看域名解析是否生效 如果显示这样，说明已经成功了，等待服务商给你生成SSL证书即可。 到这里证书这块已经搞定，下一步是解决CDN设置的问题。 设置CDN服务 进入CDN；路径：云产品-CDN-添加域名 配置见图。域名是你要加速的域名。源站是指你网站的服务器ip。我这里是使用的GitHub pages，所以使用了这4个ip。如果你不知道自己的ip，你可以去的空间商查询。另外如果你想使用类似GitHub的服务器，可以使用ping www.xxxx.com 命令查询。我是使用站长工具批量ping命令查询的。 缓存过期配置，根据自己需要酌情设置，因为是写教程，我这里就默认了。说个尝试，如果是动态的链接是不应该缓存的，所以过期时间应该是0秒。 进入高级配置，设置HTTPS证书。按图下图设置 设置完成后，点击提交，进入CDN的域名管理列表。 稍等片刻，CDN会给你提供一个域名，该域名是你把要加速的域名，通过CNAME类型解析的。如下图： 设置域名解析到CDN上。进入域名解析，添加解析。如：我需要用的域名为test.gobyte.cn，那么添加的主机名应该是test，解析类型为CNAME，记录值为test.gobyte.cn.cdn.dnsv1.com。如下图： 浏览器输入你的域名，按下F12打开开发者工具，点击network，如我的域名是http://test.gobyte.cn，打开看看能不能访问。顺带看一下head的主机ip是多少，如图： 明显看出，这个IP不是上面自己设置的源IP，通过IP查询得知，它是湖南岳阳的IP，说明它就是CDN服务器的IP了。 我们再测试下HTTPShttps://test.gobyte.cn，我这边已经成功了，如下图。 鼠标单击一下地址栏的小锁，点击证书 从证书中可以看到，是授予我的域名的。颁发者是：TrustAsia，而TrustAsia就是亚洲诚信公司，所以说明我们的HTTPS已经配置成功了！ 但是别着急，还有最后重要的一步设置没有完成。我们需要设置为强制跳转HTTPS访问，因为目前http还是可以访问的。 设置HTTPS强制跳转；打开CDN-域名管理-点击test.gobyte.cn-高级配置-HTTPS配置-强制跳转HTTPS-打开 至此，我们打开浏览器隐身模式，尝试输入不带https的域名，看看能否强制跳转。通过抓包得知，浏览器成功的利用302跳转到https协议了。 至此，使用GitHub pages + CDN + HTTPS教程已经完成，如果你在搭建的过程中遇到什么问题，或者发我的有遗漏、错误的地方，欢迎留言，最后祝大家生活愉快~","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]},{"title":"重启centOS丢失nginx.pid导致无法启动nginx的解决方法","slug":"重启centOS丢失nginx-pid导致无法启动nginx的解决方法","date":"2019-06-09T22:13:22.000Z","updated":"2023-10-07T08:53:25.041Z","comments":true,"path":"post/2f01b863.html","link":"","permalink":"https://blog.gobyte.cn/post/2f01b863.html","excerpt":"","keywords":null,"text":"找到nginx首先，如果你忘记了你的nginx的安装目录，不妨使用以下命令，找到你的nginx： 1find / -name nginx 这个时候，不出意外的话，你的界面将会出现一堆nginx路径，但是一般可执行的文件是在/sbin/或者/bin/目录下。当然，如果你的shell工具支持关键字高亮的话，一眼就能区分该是目录还是可执行文件了，以下是目录示例： 123456789101112/run/nginx/usr/lib64/nginx/usr/sbin/nginx/usr/share/nginx/usr/libexec/initscripts/legacy-actions/nginx/etc/logrotate.d/nginx/etc/sysconfig/nginx/etc/nginx/var/lib/yum/repos/x86_64/7/nginx/var/cache/nginx/var/cache/yum/x86_64/7/nginx/var/log/nginx 上述列表中，带有/sbin/或者/bin/的目录仅有一个，那就是：/usr/sbin/nginx 找到nginx的配置文件也就是找到nginx.conf文件，同样是使用查找命令： 1find / -name nginx.conf centOS这个时候一般只会出现一个配置文件路径，如下： 1/etc/nginx/nginx.conf 拼接命令，启动nginx将目录/usr/sbin/nginx加上参数 -c，再加上配置文件目录：/etc/nginx/nginx.conf 最终变成了: 1/usr/sbin/nginx -c /etc/nginx/nginx.conf 此时按下Enter执行，屏幕将会没有其他的提示，意味着nginx程序启动成功。 nginx -c 它是设置配置文件。其实nginx -c 它还有一个默认的配置文件路径。它默认的路径：/etc/nginx/nginx.conf，所以上述命令修正后是： 1/usr/sbin/nginx -c 怎么知道nginx还有其他的命令呢？ 你只需要输入以下命令即可： 1/usr/sbin/nginx -? Nginx指令拓展知识（中英对照）：1234567891011-?,-h : this help (这个帮助)-v : show version and exit （显示版本并退出）-V : show version and configure options then exit （显示版本和选项，然后退出）-t : test configuration and exit （测试配置和退出）-T : test configuration, dump it and exit （测试配置，转储并退出）-q : suppress non-error messages during configurationtesting （在配置非错误期间，禁止显示非错误消息）-s signal : send signa1 to a master process: stop, quit, reopen, reload （向主进程发送信息：停止；退出；重新打开；重新加载）-p prefix : set prefix path (default: /etc/nginx/) （设置前缀路径，默认：/etc/nginx/）-c filename : set configuration file (default: /etc/nginx/nginx. conf) （设置配置文件，默认为：/etc/nginx/nginx. conf ）-g directives : set global directives out of configuration file （将配置文件设置为全局指令）","raw":null,"content":null,"categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.gobyte.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.gobyte.cn/tags/nginx/"},{"name":"centOS","slug":"centOS","permalink":"https://blog.gobyte.cn/tags/centOS/"},{"name":"linux","slug":"linux","permalink":"https://blog.gobyte.cn/tags/linux/"}]},{"title":"windows 10 删除库后自动恢复的解决方法","slug":"windows10 删除库后自动恢复","date":"2019-06-09T07:42:58.000Z","updated":"2023-10-07T08:53:25.036Z","comments":true,"path":"post/f9458eff.html","link":"","permalink":"https://blog.gobyte.cn/post/f9458eff.html","excerpt":"","keywords":null,"text":"什么是windows 库？打开我的电脑，或者文件夹后，在左侧就会显示： 手动删除不行吗？当然不行，它就像牛皮癣一样，具体请看效果图： 如何正确的“删除”？请看操作图，确切的说，它只是被隐藏了，不会在左侧库里显示，但是“库”还在，操作方法如下：","raw":null,"content":null,"categories":[{"name":"windows","slug":"windows","permalink":"https://blog.gobyte.cn/categories/windows/"}],"tags":[{"name":"windows 10","slug":"windows-10","permalink":"https://blog.gobyte.cn/tags/windows-10/"}]},{"title":"Vue购物车演示","slug":"Vue购物车演示","date":"2019-06-07T00:39:47.000Z","updated":"2023-10-07T08:53:25.034Z","comments":true,"path":"post/6fba3644.html","link":"","permalink":"https://blog.gobyte.cn/post/6fba3644.html","excerpt":"","keywords":null,"text":"Vue购物车演示2019年6月8日00:47:29","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.gobyte.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.gobyte.cn/tags/vue/"}]},{"title":"GIT push三部曲","slug":"你好，Hexo","date":"2019-06-06T19:39:47.000Z","updated":"2023-10-07T08:53:25.036Z","comments":true,"path":"post/8ec25db2.html","link":"","permalink":"https://blog.gobyte.cn/post/8ec25db2.html","excerpt":"","keywords":null,"text":"GIT push三部曲：123git add .git commit –m &quot;注释&quot; # 或者：git push origin hexogit push HEXO命令： 编写文章之前，请pull： git pull 123hexo generate//简写hexo g hexo g -d//文件生成后立即部署网站hexo g -w//监视文件变动","raw":null,"content":null,"categories":[{"name":"博客优化","slug":"博客优化","permalink":"https://blog.gobyte.cn/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gobyte.cn/tags/Hexo/"}]}]}